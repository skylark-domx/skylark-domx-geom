{"version":3,"sources":["skylark-domx-geom.js"],"names":["define","skylark","langx","noder","styler","cachedScrollbarWidth","rootNodeRE","px","toPixel","offsetParent","borderExtents","elm","isWindow","left","top","right","bottom","s","getComputedStyle","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","boundingPosition","coords","undefined","test","nodeName","getBoundingClientRect","parent","parentOffset","mex","marginExtents","pbex","relativePosition","scrollTop","scrollLeft","this","boundingRect","boundingSize","window","document","documentElement","body","innerHeight","innerWidth","height","width","dimension","isDocument","getDocumentSize","offsetWidth","offsetHeight","isBorderBox","css","props","pex","paddingExtents","bex","clientSize","clientWidth","clientHeight","contentHeight","value","contentSize","cs","contentWidth","doc","max","Math","scrollWidth","scrollHeight","marginLeft","marginTop","marginRight","marginBottom","paddingLeft","paddingTop","paddingRight","paddingBottom","pagePosition","obj","w","ownerDocument","defaultView","pageXOffset","pageYOffset","offset","relativeRect","nodeType","scrollingElement","hasScrollLeft","scrollTo","scrollY","hasScrollTop","scrollX","viewportSize","win","geom","mixin","boundingHeight","boundingWidth","contentRect","hasScrollbar","inview","cushion","r","o","calibrate","vsize","marginRect","me","marginSize","pageRect","round","scrollbarWidth","w1","w2","div","createFragment","innerDiv","childNodes","append","remove","scrollIntoView","align","x","y","parentWidth","parentHeight","parentElm","parentNode","pos","rootElm","offsetLeft","offsetTop","getOffset","scrollBy","size","testAxis","result","attach","abs","rhorizontal","rvertical","roffset","rposition","rpercent","getOffsets","offsets","parseFloat","parseCss","element","property","parseInt","positions","fit","position","data","newOverRight","within","withinOffset","outerWidth","collisionPosLeft","collisionPosition","overLeft","overRight","collisionWidth","newOverBottom","outerHeight","collisionPosTop","overTop","overBottom","collisionHeight","flip","newOverLeft","myOffset","my","elemWidth","atOffset","at","targetWidth","newOverTop","elemHeight","targetHeight","flipfit","apply","arguments","posit","options","targetOffset","basePosition","dimensions","target","extend","of","withinElement","hasOffset","msize","scrollInfo","overflowX","overflowY","hasOverflowX","getScrollInfo","collision","split","raw","preventDefault","pageY","pageX","each","horizontalOffset","verticalOffset","length","concat","exec","elem","using","i","dir","feedback","horizontal","vertical","important","call","scrollToTop","speed","callback","scrollFrom","freq","interval","setInterval","clearInterval","debounce","velm","$","delegate","fn","wraps","wrapper_value","clone","wrapper_map","forEach","Dimension","replace","m","toUpperCase","margin","el","cb","idx","mb","main"],"mappings":";;;;;;;g4BAAAA,EAAA,0BACA,wBACA,sBACA,qBACA,uBACA,SAAAC,EAAAC,EAAAC,EAAAC,GACA,aAEA,IAGAC,EAHAC,EAAA,mBACAC,EAAAL,EAAAM,QACAC,EAAAN,EAAAM,aAsCA,SAAAC,EAAAC,GACA,GAAAR,EAAAS,SAAAD,GACA,OACAE,KAAA,EACAC,IAAA,EACAC,MAAA,EACAC,OAAA,GAEA,IAAAC,EAAAC,iBAAAP,GACA,OACAE,KAAAN,EAAAU,EAAAE,gBAAAR,GACAG,IAAAP,EAAAU,EAAAG,eAAAT,GACAI,MAAAR,EAAAU,EAAAI,iBAAAV,GACAK,OAAAT,EAAAU,EAAAK,kBAAAX,IAvDA,SAAAY,EAAAZ,EAAAa,GACA,QAAAC,IAAAD,EACA,OAAAlB,EAAAoB,KAAAf,EAAAgB,WAAAb,IAAA,EAAAD,KAAA,GAAAF,EAAAiB,wBAEA,IACAC,EAAApB,EAAAE,GAEAmB,EAAAP,EAAAM,GACAE,EAAAC,EAAArB,GACAsB,EAAAvB,EAAAmB,GAMA,OAJAK,EAAAvB,GACAG,IAAAU,EAAAV,IAAAgB,EAAAhB,IAAAiB,EAAAjB,IAAAmB,EAAAnB,KAAAqB,EAAAN,IAAA,GACAhB,KAAAW,EAAAX,KAAAiB,EAAAjB,KAAAkB,EAAAlB,KAAAoB,EAAApB,MAAAuB,EAAAP,IAAA,KAEAQ,KASA,SAAAC,EAAA3B,EAAAa,GACA,YAAAC,IAAAD,GAcAD,EAAAZ,EAAAa,GACAe,EAAA5B,EAAAa,GACAa,MAfA1B,GAAA6B,QAAA7B,GAAA8B,SAAAC,iBAAA/B,GAAA8B,SAAAE,MAEA7B,IAAA,EACAD,KAAA,EACAG,OAAAwB,OAAAI,YACA7B,MAAAyB,OAAAK,WACAC,OAAAN,OAAAI,YACAG,MAAAP,OAAAK,YAEAlC,EAAAiB,sBACAjB,EAAAiB,6BADA,EAgBA,SAAAW,EAAA5B,EAAAqC,GACA,QAAAvB,GAAAuB,EACA,OAAA9C,EAAAU,SAAAD,IAEAoC,MAAApC,EAAAkC,WACAC,OAAAnC,EAAAiC,aAGA1C,EAAA+C,WAAAtC,GACAuC,EAAAT,WAGAM,MAAApC,EAAAwC,YACAL,OAAAnC,EAAAyC,cAIA,IAAAC,EAAA,eAAAjD,EAAAkD,IAAA3C,EAAA,cACA4C,GACAR,MAAAC,EAAAD,MACAD,OAAAE,EAAAF,QAEA,IAAAO,EAAA,CACA,IAAAG,EAAAC,EAAA9C,GACA+C,EAAAhD,EAAAC,QAEAc,IAAA8B,EAAAR,OAAA,KAAAQ,EAAAR,OAAA,OAAAQ,EAAAR,QACAQ,EAAAR,MAAAQ,EAAAR,MAAAS,EAAA3C,KAAA2C,EAAAzC,MAAA2C,EAAA7C,KAAA6C,EAAA3C,YAGAU,IAAA8B,EAAAT,QAAA,KAAAS,EAAAT,QAAA,OAAAS,EAAAT,SACAS,EAAAT,OAAAS,EAAAT,OAAAU,EAAA1C,IAAA0C,EAAAxC,OAAA0C,EAAA5C,IAAA4C,EAAA1C,QAIA,OADAZ,EAAAkD,IAAA3C,EAAA4C,GACAlB,KAyCA,SAAAsB,EAAAhD,EAAAqC,GACA,QAAAvB,GAAAuB,EACA,OACAD,MAAApC,EAAAiD,aAAAjD,EAAAkC,WACAC,OAAAnC,EAAAkD,cAAAlD,EAAAiC,aAGA,IAAAS,EAAA,eAAAjD,EAAAkD,IAAA3C,EAAA,cACA4C,GACAR,MAAAC,EAAAD,MACAD,OAAAE,EAAAF,QAEA,GAAAO,EAUA,CACA,IAAAK,EAAAhD,EAAAC,QAEAc,IAAA8B,EAAAR,QACAQ,EAAAR,MAAAQ,EAAAR,MAAAW,EAAA7C,KAAA6C,EAAA3C,YAGAU,IAAA8B,EAAAT,SACAS,EAAAT,OAAAS,EAAAT,OAAAY,EAAA5C,IAAA4C,EAAA1C,YAlBA,CACA,IAAAwC,EAAAC,EAAA9C,QAEAc,IAAA8B,EAAAR,QACAQ,EAAAR,MAAAQ,EAAAR,MAAAS,EAAA3C,KAAA2C,EAAAzC,YAGAU,IAAA8B,EAAAT,SACAS,EAAAT,OAAAS,EAAAT,OAAAU,EAAA1C,IAAA0C,EAAAxC,QAeA,OADAZ,EAAAkD,IAAA3C,EAAA4C,GACAlB,KA6BA,SAAAyB,EAAAnD,EAAAoD,GACA,YAAAtC,GAAAsC,EACAC,EAAArD,GAAAmC,QAEAkB,EAAArD,GACAmC,OAAAiB,IAEA1B,MA8BA,SAAA2B,EAAArD,EAAAqC,GACA,IAAAiB,EAAAN,EAAAhD,GACA6C,EAAAC,EAAA9C,GAEA,QAAAc,IAAAuB,EACA,OACAD,MAAAkB,EAAAlB,MAAAS,EAAA3C,KAAA2C,EAAAzC,MACA+B,OAAAmB,EAAAnB,OAAAU,EAAA1C,IAAA0C,EAAAxC,QAGA,IAAAqC,EAAA,eAAAjD,EAAAkD,IAAA3C,EAAA,cACA4C,GACAR,MAAAC,EAAAD,MACAD,OAAAE,EAAAF,QAEA,GAAAO,EAAA,CACA,IAAAK,EAAAhD,EAAAC,QAEAc,IAAA8B,EAAAR,OAAA,KAAAQ,EAAAR,OAAA,OAAAQ,EAAAR,QACAQ,EAAAR,MAAAQ,EAAAR,MAAAS,EAAA3C,KAAA2C,EAAAzC,MAAA2C,EAAA7C,KAAA6C,EAAA3C,YAGAU,IAAA8B,EAAAT,QAAA,KAAAS,EAAAT,QAAA,OAAAS,EAAAT,SACAS,EAAAT,OAAAS,EAAAT,OAAAU,EAAA1C,IAAA0C,EAAAxC,OAAA0C,EAAA5C,IAAA4C,EAAA1C,QAIA,OADAZ,EAAAkD,IAAA3C,EAAA4C,GACAlB,KAUA,SAAA6B,EAAAvD,EAAAoD,GACA,YAAAtC,GAAAsC,EACAC,EAAArD,GAAAoC,OAEAiB,EAAArD,GACAoC,MAAAgB,IAEA1B,MASA,SAAAa,EAAAiB,GACA,IAAAzB,EAAAyB,EAAAzB,gBACAC,EAAAwB,EAAAxB,KACAyB,EAAAC,KAAAD,IACAE,EAAAF,EAAA1B,EAAA4B,YAAA3B,EAAA2B,aACAV,EAAAQ,EAAA1B,EAAAkB,YAAAjB,EAAAiB,aACAT,EAAAiB,EAAA1B,EAAAS,YAAAR,EAAAQ,aACAoB,EAAAH,EAAA1B,EAAA6B,aAAA5B,EAAA4B,cACAV,EAAAO,EAAA1B,EAAAmB,aAAAlB,EAAAkB,cACAT,EAAAgB,EAAA1B,EAAAU,aAAAT,EAAAS,cAEA,OACAL,MAAAuB,EAAAnB,EAAAS,EAAAU,EACAxB,OAAAyB,EAAAnB,EAAAS,EAAAU,GAyBA,SAAAvC,EAAArB,GACA,GAAAR,EAAAS,SAAAD,GACA,OACAE,KAAA,EACAC,IAAA,EACAC,MAAA,EACAC,OAAA,GAGA,IAAAC,EAAAC,iBAAAP,GACA,OACAE,KAAAN,EAAAU,EAAAuD,YACA1D,IAAAP,EAAAU,EAAAwD,WACA1D,MAAAR,EAAAU,EAAAyD,aACA1D,OAAAT,EAAAU,EAAA0D,eAgCA,SAAAlB,EAAA9C,GACA,GAAAR,EAAAS,SAAAD,GACA,OACAE,KAAA,EACAC,IAAA,EACAC,MAAA,EACAC,OAAA,GAGA,IAAAC,EAAAC,iBAAAP,GACA,OACAE,KAAAN,EAAAU,EAAA2D,aACA9D,IAAAP,EAAAU,EAAA4D,YACA9D,MAAAR,EAAAU,EAAA6D,cACA9D,OAAAT,EAAAU,EAAA8D,gBAUA,SAAAC,EAAArE,EAAAa,GACA,QAAAC,IAAAD,EAAA,CACA,IAAAyD,EAAAtE,EAAAiB,wBACAsD,EAAAvE,EAAAwE,cAAAC,YACA,OACAvE,KAAAoE,EAAApE,KAAAqE,EAAAG,YACAvE,IAAAmE,EAAAnE,IAAAoE,EAAAI,aAGA,IACAzD,EAAApB,EAAAE,GAEAmB,EAAAkD,EAAAnD,GACAE,EAAAC,EAAArB,GACAsB,EAAAvB,EAAAmB,GAMA,OAJAK,EAAAvB,GACAG,IAAAU,EAAAV,IAAAgB,EAAAhB,IAAAiB,EAAAjB,IAAAmB,EAAAnB,IACAD,KAAAW,EAAAX,KAAAiB,EAAAjB,KAAAkB,EAAAlB,KAAAoB,EAAApB,OAEAwB,KAgCA,SAAAH,EAAAvB,EAAAa,GACA,QAAAC,GAAAD,EAAA,CACA,IACAK,EAAApB,EAAAE,GAEA4E,EAAAhE,EAAAZ,GACAmB,EAAAP,EAAAM,GACAE,EAAAC,EAAArB,GACAsB,EAAAvB,EAAAmB,GAGA,OACAf,IAAAyE,EAAAzE,IAAAgB,EAAAhB,IAAAmB,EAAAnB,IAAAiB,EAAAjB,IACAD,KAAA0E,EAAA1E,KAAAiB,EAAAjB,KAAAoB,EAAApB,KAAAkB,EAAAlB,MAGA,IACAgB,EAAApB,EAAAE,GAEA4C,GACAzC,IAAAU,EAAAV,IACAD,KAAAW,EAAAX,MAmBA,MANA,UAAAT,EAAAkD,IAAA3C,EAAA,cACA4C,EAAA,SAAA,YAIAnD,EAAAkD,IAAA3C,EAAA4C,GACAlB,KASA,SAAAmD,EAAA7E,EAAAa,GACA,QAAAC,IAAAD,EAAA,CACA,IACAK,EAAApB,EAAAE,GAEA4E,EAAAjD,EAAA3B,GACAmB,EAAAP,EAAAM,GAEAI,GADAD,EAAArB,GACAD,EAAAmB,IAGA,OACAf,IAAAyE,EAAAzE,IAAAgB,EAAAhB,IAAAmB,EAAAnB,IACAD,KAAA0E,EAAA1E,KAAAiB,EAAAjB,KAAAoB,EAAApB,KACAkC,MAAAwC,EAAAxC,MACAD,OAAAyC,EAAAzC,QAKA,OAFAZ,EAAAvB,EAAAa,GACAe,EAAA5B,EAAAa,GACAa,KAmDA,SAAAD,EAAAzB,EAAAoD,GACA,IAAApD,EAAA8E,SACA9E,EAAAA,EAAAyE,YACAzE,GAAA8B,SAAAE,OACAhC,EAAA8B,SAAAiD,kBAAAjD,SAAAC,iBAEA,IAAAiD,EAAA,eAAAhF,EACA,YAAAc,IAAAsC,EACA4B,EAAAhF,EAAAyB,WAAAzB,EAAA0E,aAEAM,EACAhF,EAAAyB,WAAA2B,EAEApD,EAAAiF,SAAA7B,EAAApD,EAAAkF,SAEAxD,MAQA,SAAAF,EAAAxB,EAAAoD,GACA,IAAApD,EAAA8E,SACA9E,EAAAA,EAAAyE,YACAzE,GAAA8B,SAAAE,OACAhC,EAAA8B,SAAAiD,kBAAAjD,SAAAC,iBAGA,IAAAoD,EAAA,cAAAnF,EAEA,YAAAc,IAAAsC,EACA+B,EAAAnF,EAAAwB,UAAAxB,EAAA2E,aAEAQ,EACAnF,EAAAwB,UAAA4B,EAEApD,EAAAiF,SAAAjF,EAAAoF,QAAAhC,GAEA1B,MAWA,SAAA2D,EAAAC,GAGA,OAAA3D,EAFA2D,EAAAA,GAAAzD,QA6CA,SAAA0D,IACA,OAAAA,EAqEA,OAlEAhG,EAAAiG,MAAAD,GACAxF,cAAAA,EAEA0F,eAxlBA,SAAAzF,EAAAoD,GACA,YAAAtC,GAAAsC,EACAxB,EAAA5B,GAAAmC,QAEAP,EAAA5B,GACAmC,OAAAiB,IAEA1B,OAklBAd,iBAAAA,EACAe,aAAAA,EACAC,aAAAA,EACA8D,cA7jBA,SAAA1F,EAAAoD,GACA,YAAAtC,GAAAsC,EACAxB,EAAA5B,GAAAoC,OAEAR,EAAA5B,GACAoC,MAAAgB,IAEA1B,OAwjBAwB,aA/iBA,SAAAlD,EAAAoD,GACA,YAAAtC,GAAAsC,EACAJ,EAAAhD,GAAAmC,OAEAa,EAAAhD,GACAmC,OAAAiB,KA2iBAJ,WAAAA,EACAC,YAlfA,SAAAjD,EAAAoD,GACA,YAAAtC,GAAAsC,EACAJ,EAAAhD,GAAAoC,OAEAY,EAAAhD,GACAoC,MAAAgB,IAEA1B,OA6eAyB,cAAAA,EACAwC,YAtdA,SAAA3F,GACA,IAAAsD,EAAAN,EAAAhD,GACA6C,EAAAC,EAAA9C,GAQA,OACAE,KAAA2C,EAAA3C,KACAC,IAAA0C,EAAA1C,IACAiC,MAAAkB,EAAAlB,MAAAS,EAAA3C,KAAA2C,EAAAzC,MACA+B,OAAAmB,EAAAnB,OAAAU,EAAA1C,IAAA0C,EAAAxC,SAycAgD,YAAAA,EACAE,aAAAA,EAEAhB,gBAAAA,EAEAqD,aAxoBA,WACA,OAAA9D,SAAAE,KAAA4B,cAAA/B,OAAAI,aAAAH,SAAAC,gBAAAmB,eAyoBAf,OAAAgB,EAEA0C,OAnYA,SAAA7F,EAAA8F,GASA,IAAAC,EARA,SAAAlF,EAAAiF,GACA,IAAAE,KAIA,OAHAF,GAAAA,GAAA,EACAE,EAAA5D,OAAA4D,EAAA5F,MAAAS,EAAAT,MAAA0F,IAAAE,EAAA9F,KAAAW,EAAAX,KAAA4F,GACAE,EAAA7D,QAAA6D,EAAA3F,OAAAQ,EAAAR,OAAAyF,IAAAE,EAAA7F,IAAAU,EAAAV,IAAA2F,GACAE,EAGAC,CAAAtE,EAAA3B,GAAA8F,GACAI,EAAAb,IAEA,QAAAU,GAAAA,EAAA1F,QAAA,GAAA0F,EAAA3F,OAAA,GAAA2F,EAAA5F,KAAA+F,EAAA/D,QAAA4D,EAAA7F,MAAAgG,EAAA9D,OAyXAf,cAAAA,EAEA8E,WAhWA,SAAAnG,GACA,IAAAsE,EAAAO,EAAA7E,GACAoG,EAAA/E,EAAArB,GAEA,OACAE,KAAAoE,EAAApE,KACAC,IAAAmE,EAAAnE,IACAiC,MAAAkC,EAAAlC,MAAAgE,EAAAlG,KAAAkG,EAAAhG,MACA+B,OAAAmC,EAAAnC,OAAAiE,EAAAjG,IAAAiG,EAAA/F,SAyVAgG,WApVA,SAAArG,GACA,IAAAsE,EAAA1C,EAAA5B,GACAoG,EAAA/E,EAAArB,GAEA,OACAoC,MAAAkC,EAAAlC,MAAAgE,EAAAlG,KAAAkG,EAAAhG,MACA+B,OAAAmC,EAAAnC,OAAAiE,EAAAjG,IAAAiG,EAAA/F,SAgVAP,aAAAA,EAEAgD,eAAAA,EAGAuB,aAAAA,EAEAiC,SA1RA,SAAAtG,EAAAa,GACA,QAAAC,IAAAD,EAAA,CACA,IAAAyD,EAAAtE,EAAAiB,wBACAsD,EAAAvE,EAAAwE,cAAAC,YACA,OACAvE,KAAAoE,EAAApE,KAAAqE,EAAAG,YACAvE,IAAAmE,EAAAnE,IAAAoE,EAAAI,YACAvC,MAAAsB,KAAA6C,MAAAjC,EAAAlC,OACAD,OAAAuB,KAAA6C,MAAAjC,EAAAnC,SAKA,OAFAkC,EAAArE,EAAAa,GACAe,EAAA5B,EAAAa,GACAa,MAgRAH,iBAAAA,EAEAsD,aAAAA,EAEA2B,eA5rBA,WACA,QAAA1F,IAAApB,EACA,OAAAA,EAEA,IAAA+G,EAAAC,EACAC,EAAAnH,EAAAoH,eAAA,6IAEA,GACAC,EAAAF,EAAAG,WAAA,GAEAtH,EAAAuH,OAAAjF,SAAAE,KAAA2E,GAEAF,EAAAI,EAAArE,YACA/C,EAAAkD,IAAAgE,EAAA,WAAA,UAEAD,EAAAG,EAAArE,YAEAiE,IAAAC,IACAA,EAAAC,EAAA,GAAA1D,aAKA,OAFAzD,EAAAwH,OAAAL,GAEAjH,EAAA+G,EAAAC,GAuqBAO,eA/LA,SAAAjH,EAAAkH,GAcA,IACAC,EAAAC,EAAAhF,EAAAD,EAAAkF,EAAAC,EADAC,EAAAvH,EAAAwH,WAEAC,EAfA,SAAAzH,EAAA0H,GACA,IAAAP,EAAAC,EAAAlG,EAAAlB,EAEAmH,EAAAC,EAAA,EACA,KAAAlG,GAAAA,GAAAwG,GAAAxG,EAAA4D,UACAqC,GAAAjG,EAAAyG,YAAA,EACAP,GAAAlG,EAAA0G,WAAA,EACA1G,EAAAA,EAAApB,aAGA,OAAAqH,EAAAA,EAAAC,EAAAA,GAKAS,CAAA7H,EAAAuH,GAEAJ,EAAAM,EAAAN,EACAC,EAAAK,EAAAL,EACAhF,EAAApC,EAAAwC,YACAL,EAAAnC,EAAAyC,aACA4E,EAAAE,EAAAtE,YACAqE,EAAAC,EAAArE,aAEA,OAAAgE,GACAC,GAAAE,EAAAjF,EACAgF,GAAAE,EAAAnF,GACA,UAAA+E,IACAC,GAAAE,EAAA,EAAAjF,EAAA,EACAgF,GAAAE,EAAA,EAAAnF,EAAA,GAMA,OAHAoF,EAAA9F,WAAA0F,EACAI,EAAA/F,UAAA4F,EAEA1F,MA6JAD,WAAAA,EAEAD,UAAAA,EAEAsG,SA9GA,SAAA9H,EAAAmH,EAAAC,GACApH,EAAAyB,YAAA0F,EACAnH,EAAAwB,WAAA4F,GA8GAW,KAAA1E,EAEA2E,SAnGA,SAAAhI,GAEA,IAAAG,EAAAH,EAAA4H,UACA1H,EAAAF,EAAA2H,WACAvF,EAAApC,EAAAwC,YACAL,EAAAnC,EAAAyC,aAEA,KAAAzC,EAAAF,cACAE,EAAAA,EAAAF,aACAK,GAAAH,EAAA4H,UACA1H,GAAAF,EAAA2H,WAGA,IAAAM,GAAAd,EAAA,EAAAC,EAAA,GAGAjH,EAAA0B,OAAA8C,YACAsD,EAAAb,EAAAjH,EAAA0B,OAAA8C,YAGAxE,EAAAgC,EAAAN,OAAA8C,YAAA9C,OAAAI,cAEAgG,EAAAb,EAAAjH,EAAAgC,GAAAN,OAAA8C,YAAA9C,OAAAI,cAIA/B,EAAA2B,OAAA6C,YACAuD,EAAAd,EAAAjH,EAAA2B,OAAA6C,YAGAxE,EAAAkC,EAAAP,OAAA6C,YAAA7C,OAAAK,aAEA+F,EAAAd,EAAAjH,EAAAkC,GAAAP,OAAA6C,YAAA7C,OAAAK,aAGA,OAAA+F,GAkEA5C,aAAAA,EAEAjD,MAAAmB,IAKAjE,EAAA4I,OAAA,YAAA3C,KAEAlG,EAAA,2BACA,sBACA,qBACA,sBACA,UACA,SAAAE,EAAAC,EAAAC,EAAA8F,GACA,aAEA,IAAA9B,EAAAC,KAAAD,IACA0E,EAAAzE,KAAAyE,IACAC,EAAA,oBACAC,EAAA,oBACAC,EAAA,wBACAC,EAAA,OACAC,EAAA,KAEA,SAAAC,EAAAC,EAAAtG,EAAAD,GACA,OACAwG,WAAAD,EAAA,KAAAF,EAAAzH,KAAA2H,EAAA,IAAAtG,EAAA,IAAA,GACAuG,WAAAD,EAAA,KAAAF,EAAAzH,KAAA2H,EAAA,IAAAvG,EAAA,IAAA,IAIA,SAAAyG,EAAAC,EAAAC,GACA,OAAAC,SAAAtJ,EAAAkD,IAAAkG,EAAAC,GAAA,KAAA,EAqPA,IAAAE,GACAC,KACA/I,KAAA,SAAAgJ,EAAAC,GACA,IAMAC,EANAC,EAAAF,EAAAE,OACAC,EAAAD,EAAApJ,SAAAoJ,EAAA5H,WAAA4H,EAAAzE,OAAA1E,KACAqJ,EAAAF,EAAAjH,MACAoH,EAAAN,EAAAhJ,KAAAiJ,EAAAM,kBAAA5F,WACA6F,EAAAJ,EAAAE,EACAG,EAAAH,EAAAL,EAAAS,eAAAL,EAAAD,EAIAH,EAAAS,eAAAL,EAGAG,EAAA,GAAAC,GAAA,GACAP,EAAAF,EAAAhJ,KAAAwJ,EAAAP,EAAAS,eAAAL,EACAD,EACAJ,EAAAhJ,MAAAwJ,EAAAN,GAIAF,EAAAhJ,KADAyJ,EAAA,GAAAD,GAAA,EACAJ,EAIAI,EAAAC,EACAL,EAAAC,EAAAJ,EAAAS,eAEAN,EAKAI,EAAA,EACAR,EAAAhJ,MAAAwJ,EAGAC,EAAA,EACAT,EAAAhJ,MAAAyJ,EAIAT,EAAAhJ,KAAAuD,EAAAyF,EAAAhJ,KAAAsJ,EAAAN,EAAAhJ,OAGAC,IAAA,SAAA+I,EAAAC,GACA,IAMAU,EANAR,EAAAF,EAAAE,OACAC,EAAAD,EAAApJ,SAAAoJ,EAAA7H,UAAA6H,EAAAzE,OAAAzE,IACA2J,EAAAX,EAAAE,OAAAlH,OACA4H,EAAAb,EAAA/I,IAAAgJ,EAAAM,kBAAA3F,UACAkG,EAAAV,EAAAS,EACAE,EAAAF,EAAAZ,EAAAe,gBAAAJ,EAAAR,EAIAH,EAAAe,gBAAAJ,EAGAE,EAAA,GAAAC,GAAA,GACAJ,EAAAX,EAAA/I,IAAA6J,EAAAb,EAAAe,gBAAAJ,EACAR,EACAJ,EAAA/I,KAAA6J,EAAAH,GAIAX,EAAA/I,IADA8J,EAAA,GAAAD,GAAA,EACAV,EAIAU,EAAAC,EACAX,EAAAQ,EAAAX,EAAAe,gBAEAZ,EAKAU,EAAA,EACAd,EAAA/I,KAAA6J,EAGAC,EAAA,EACAf,EAAA/I,KAAA8J,EAIAf,EAAA/I,IAAAsD,EAAAyF,EAAA/I,IAAA4J,EAAAb,EAAA/I,OAIAgK,MACAjK,KAAA,SAAAgJ,EAAAC,GACA,IAkBAC,EACAgB,EAnBAf,EAAAF,EAAAE,OACAC,EAAAD,EAAAzE,OAAA1E,KAAAmJ,EAAA5H,WACA8H,EAAAF,EAAAjH,MACAuF,EAAA0B,EAAApJ,SAAAoJ,EAAA5H,WAAA4H,EAAAzE,OAAA1E,KACAsJ,EAAAN,EAAAhJ,KAAAiJ,EAAAM,kBAAA5F,WACA6F,EAAAF,EAAA7B,EACAgC,EAAAH,EAAAL,EAAAS,eAAAL,EAAA5B,EACA0C,EAAA,SAAAlB,EAAAmB,GAAA,IACAnB,EAAAoB,UACA,UAAApB,EAAAmB,GAAA,GACAnB,EAAAoB,UACA,EACAC,EAAA,SAAArB,EAAAsB,GAAA,GACAtB,EAAAuB,YACA,UAAAvB,EAAAsB,GAAA,IACAtB,EAAAuB,YACA,EACA9F,GAAA,EAAAuE,EAAAvE,OAAA,GAIA8E,EAAA,IACAN,EAAAF,EAAAhJ,KAAAmK,EAAAG,EAAA5F,EAAAuE,EAAAS,eACAL,EAAAD,GACA,GAAAF,EAAAjB,EAAAuB,MACAR,EAAAhJ,MAAAmK,EAAAG,EAAA5F,GAEA+E,EAAA,KACAS,EAAAlB,EAAAhJ,KAAAiJ,EAAAM,kBAAA5F,WAAAwG,EACAG,EAAA5F,EAAA+C,GACA,GAAAQ,EAAAiC,GAAAT,KACAT,EAAAhJ,MAAAmK,EAAAG,EAAA5F,IAIAzE,IAAA,SAAA+I,EAAAC,GACA,IAmBAwB,EACAd,EApBAR,EAAAF,EAAAE,OACAC,EAAAD,EAAAzE,OAAAzE,IAAAkJ,EAAA7H,UACAsI,EAAAT,EAAAlH,OACAyF,EAAAyB,EAAApJ,SAAAoJ,EAAA7H,UAAA6H,EAAAzE,OAAAzE,IACA4J,EAAAb,EAAA/I,IAAAgJ,EAAAM,kBAAA3F,UACAkG,EAAAD,EAAAnC,EACAqC,EAAAF,EAAAZ,EAAAe,gBAAAJ,EAAAlC,EACAzH,EAAA,QAAAgJ,EAAAmB,GAAA,GACAD,EAAAlK,GACAgJ,EAAAyB,WACA,WAAAzB,EAAAmB,GAAA,GACAnB,EAAAyB,WACA,EACAJ,EAAA,QAAArB,EAAAsB,GAAA,GACAtB,EAAA0B,aACA,WAAA1B,EAAAsB,GAAA,IACAtB,EAAA0B,aACA,EACAjG,GAAA,EAAAuE,EAAAvE,OAAA,GAGAoF,EAAA,IACAH,EAAAX,EAAA/I,IAAAkK,EAAAG,EAAA5F,EAAAuE,EAAAe,gBACAJ,EAAAR,GACA,GAAAO,EAAA1B,EAAA6B,MACAd,EAAA/I,KAAAkK,EAAAG,EAAA5F,GAEAqF,EAAA,KACAU,EAAAzB,EAAA/I,IAAAgJ,EAAAM,kBAAA3F,UAAAuG,EAAAG,EACA5F,EAAAgD,GACA,GAAAO,EAAAwC,GAAAV,KACAf,EAAA/I,KAAAkK,EAAAG,EAAA5F,KAKAkG,SACA5K,KAAA,WACA8I,EAAAmB,KAAAjK,KAAA6K,MAAArJ,KAAAsJ,WACAhC,EAAAC,IAAA/I,KAAA6K,MAAArJ,KAAAsJ,YAEA7K,IAAA,WACA6I,EAAAmB,KAAAhK,IAAA4K,MAAArJ,KAAAsJ,WACAhC,EAAAC,IAAA9I,IAAA4K,MAAArJ,KAAAsJ,cAKA,OAAAzF,EAAA0F,MAhWA,SAAAjL,EAAAkL,GAIA,IAAAV,EAAAE,EAAAG,EAAAM,EAAAC,EAAAC,EACAC,GAHAJ,EAAA3L,EAAAgM,UAAAL,IAGAM,GACAnC,GAxBAR,EAwBAqC,EAAA7B,OAvBAoC,EAAA5C,GAAAhH,OACA5B,EAAAT,EAAAS,SAAAwL,GACAnJ,IAAAmJ,GAAA,IAAAA,EAAA3G,SACA4G,GAAAzL,IAAAqC,EACAqJ,EAAApG,EAAAc,WAAAoF,IAEA5C,QAAA4C,EACAxL,SAAAA,EACAqC,WAAAA,EACAsC,OAAA8G,EAAAnG,EAAAlB,aAAAwE,IAAA3I,KAAA,EAAAC,IAAA,GACAsB,WAAA8D,EAAA9D,WAAAgK,GACAjK,UAAA+D,EAAA/D,UAAAiK,GACArJ,MAAAuJ,EAAAvJ,MACAD,OAAAwJ,EAAAxJ,SAWAyJ,EAxCA,SAAAvC,GACA,IAAAwC,EAAAxC,EAAApJ,UAAAoJ,EAAA/G,WAAA,GACA7C,EAAAkD,IAAA0G,EAAAR,QAAA,cACAiD,EAAAzC,EAAApJ,UAAAoJ,EAAA/G,WAAA,GACA7C,EAAAkD,IAAA0G,EAAAR,QAAA,cACAkD,EAAA,WAAAF,GACA,SAAAA,GAAAxC,EAAAjH,MAAAmD,EAAA5B,YAAA0F,EAAAR,SAGA,OACAzG,MAHA,WAAA0J,GACA,SAAAA,GAAAzC,EAAAlH,OAAAoD,EAAA3B,aAAAyF,EAAAR,SAEAtD,EAAAiB,iBAAA,EACArE,OAAA4J,EAAAxG,EAAAiB,iBAAA,GA6BAwF,CAAA3C,GACA4C,GAAAf,EAAAe,WAAA,QAAAC,MAAA,KACAxD,KA3BA,IAAAG,EACA4C,EACAxL,EACAqC,EACAoJ,EACAC,EAtDAQ,EA8EAb,EAAAD,EA7EA,IAAAc,EAAArH,UAEAiD,KAAAA,KAAAoE,GACAvH,QAAAzE,IAAA,EAAAD,KAAA,IAGAV,EAAAS,SAAAkM,IAEApE,KAAAxC,EAAAwC,KAAAoE,GACAvH,QACAzE,IAAAoF,EAAA/D,UAAA2K,GACAjM,KAAAqF,EAAA9D,WAAA0K,KAIAA,EAAAC,gBAEArE,MACA3F,MAAA,EACAD,OAAA,GAEAyC,QACAzE,IAAAgM,EAAAE,MACAnM,KAAAiM,EAAAG,SAKAvE,KAAAxC,EAAAwC,KAAAoE,GACAvH,OAAAW,EAAAlB,aAAA8H,IAiDAb,EAAAc,iBAGAlB,EAAAT,GAAA,YAlFA,IAAA0B,EAoFAzB,EAAAW,EAAAtD,KAAA3F,MACAyI,EAAAQ,EAAAtD,KAAA5F,OACAgJ,EAAAE,EAAAzG,OAGAwG,EAAA7L,EAAAgM,UAAAJ,GAIA5L,EAAAgN,MAAA,KAAA,MAAA,WACA,IACAC,EACAC,EAFAhF,GAAAyD,EAAAxJ,OAAA,IAAAwK,MAAA,KAIA,IAAAzE,EAAAiF,SACAjF,EAAAW,EAAArH,KAAA0G,EAAA,IACAA,EAAAkF,QAAA,WACAtE,EAAAtH,KAAA0G,EAAA,KACA,UAAAkF,OAAAlF,IACA,SAAA,WAEAA,EAAA,GAAAW,EAAArH,KAAA0G,EAAA,IAAAA,EAAA,GAAA,SACAA,EAAA,GAAAY,EAAAtH,KAAA0G,EAAA,IAAAA,EAAA,GAAA,SAGA+E,EAAAlE,EAAAsE,KAAAnF,EAAA,IACAgF,EAAAnE,EAAAsE,KAAAnF,EAAA,IACAiB,EAAAhH,OACA8K,EAAAA,EAAA,GAAA,EACAC,EAAAA,EAAA,GAAA,GAIAvB,EAAAxJ,OACA6G,EAAAqE,KAAAnF,EAAA,IAAA,GACAc,EAAAqE,KAAAnF,EAAA,IAAA,MAKA,IAAAwE,EAAAS,SACAT,EAAA,GAAAA,EAAA,IAGA,UAAAf,EAAAT,GAAA,GACAW,EAAAlL,MAAAwK,EACA,WAAAQ,EAAAT,GAAA,KACAW,EAAAlL,MAAAwK,EAAA,GAGA,WAAAQ,EAAAT,GAAA,GACAW,EAAAjL,KAAA0K,EACA,WAAAK,EAAAT,GAAA,KACAW,EAAAjL,KAAA0K,EAAA,GAOA,OAJAL,EAAA/B,EAAAC,EAAA+B,GAAAC,EAAAG,GACAO,EAAAlL,MAAAsK,EAAA,GACAY,EAAAjL,KAAAqK,EAAA,GAEA,SAAAqC,GACA,IAAApD,EAAAqD,EACAnB,EAAApG,EAAAc,WAAAwG,GACAtC,EAAAoB,EAAAvJ,MACAwI,EAAAe,EAAAxJ,OACA0B,EAAA+E,EAAAiE,EAAA,cACA/I,EAAA8E,EAAAiE,EAAA,aACAjD,EAAAW,EAAA1G,EAAA+E,EAAAiE,EAAA,eACAjB,EAAAxJ,MACA8H,EAAAU,EAAA9G,EAAA8E,EAAAiE,EAAA,gBACAjB,EAAAzJ,OACA+G,EAAA3J,EAAAgM,UAAAH,GACAf,EAAA5B,EAAAC,EAAA4B,GAAAqB,EAAAvJ,MAAAuJ,EAAAxJ,QAEA,UAAA+I,EAAAZ,GAAA,GACApB,EAAAhJ,MAAAqK,EACA,WAAAW,EAAAZ,GAAA,KACApB,EAAAhJ,MAAAqK,EAAA,GAGA,WAAAW,EAAAZ,GAAA,GACApB,EAAA/I,KAAAyK,EACA,WAAAM,EAAAZ,GAAA,KACApB,EAAA/I,KAAAyK,EAAA,GAGA1B,EAAAhJ,MAAAmK,EAAA,GACAnB,EAAA/I,KAAAkK,EAAA,GAEAZ,GACA5F,WAAAA,EACAC,UAAAA,GAGAvE,EAAAgN,MAAA,OAAA,OAAA,SAAAQ,EAAAC,GACAhE,EAAAiD,EAAAc,KACA/D,EAAAiD,EAAAc,IAAAC,GAAA9D,GACAwB,YAAAA,EACAG,aAAAA,EACAN,UAAAA,EACAK,WAAAA,EACAnB,kBAAAA,EACAG,eAAAA,EACAM,gBAAAA,EACAtF,QAAA4F,EAAA,GAAAH,EAAA,GAAAG,EAAA,GAAAH,EAAA,IACAC,GAAAY,EAAAZ,GACAG,GAAAS,EAAAT,GACApB,OAAAA,EACAwD,KAAAA,MAKA3B,EAAA4B,QAGAA,EAAA,SAAAlK,GACA,IAAA1C,EAAAiL,EAAAjL,KAAAgJ,EAAAhJ,KACAE,EAAAF,EAAAwK,EAAAH,EACApK,EAAAgL,EAAAhL,IAAA+I,EAAA/I,IACAE,EAAAF,EAAA0K,EAAAD,EACAqC,GACA3B,QACAzC,QAAAyC,EACApL,KAAAiL,EAAAjL,KACAC,IAAAgL,EAAAhL,IACAiC,MAAAsI,EACAvI,OAAA0I,GAEAhC,SACAA,QAAAgE,EACA3M,KAAAgJ,EAAAhJ,KACAC,IAAA+I,EAAA/I,IACAiC,MAAAmI,EACApI,OAAAyI,GAEAsC,WAAA9M,EAAA,EAAA,OAAAF,EAAA,EAAA,QAAA,SACAiN,SAAA9M,EAAA,EAAA,MAAAF,EAAA,EAAA,SAAA,UAEAuK,EAAAH,GAAApC,EAAAjI,EAAAE,GAAAsK,IACAuC,EAAAC,WAAA,UAEArC,EAAAD,GAAAzC,EAAAhI,EAAAE,GAAAwK,IACAoC,EAAAE,SAAA,UAEA1J,EAAA0E,EAAAjI,GAAAiI,EAAA/H,IAAAqD,EAAA0E,EAAAhI,GAAAgI,EAAA9H,IACA4M,EAAAG,UAAA,aAEAH,EAAAG,UAAA,WAEAlC,EAAA4B,MAAAO,KAAA3L,KAAAkB,EAAAqK,KAIA1H,EAAAlB,aAAAwI,EAAAtN,EAAAgM,OAAArC,GAAA4D,MAAAA,KA9FA,CA+FA9M,MAsLAX,EAAA,mCACA,gBACA,sBACA,UACA,SAAAE,EAAAE,EAAA8F,GA6BA,OAAAA,EAAA+H,YArBA,SAAAtN,EAAAyH,EAAA8F,EAAAC,GACA,IAAAC,EAAA1E,SAAA/I,EAAAwB,WACAuL,EAAA,EAEAW,EAAA,IAAAH,EADA,EAEAtI,EAAA8D,SAAAtB,GAEAkG,EAAAC,YAAA,aACAb,GAEAW,IAAA1N,EAAAwB,WAAAyD,EAAAwI,GAAAC,EAAAX,EAAAU,GAEAV,GAAAW,EAAA,IACAG,cAAAF,GACAH,GAAAjO,EAAAuO,SAAAN,EAAA,IAAAjO,KAXA,GAeA,OAAAmC,QAKArC,EAAA,0BACA,sBACA,SACA,oBACA,qBACA,UACA,mBACA,SAAAE,EAAAgG,EAAAwI,EAAAC,GAmIA,OAjIAD,EAAAE,UACA,gBACA,mBACA,iBACA,eACA,eACA,gBAEA,eACA,aACA,cAEA,gBACA,cACA,cACA,eAGA,gBACA,aACA,aACA,eACA,iBACA,eACA,WACA,mBACA,eACA,iBACA,aACA,aAGA1I,MAIAyI,EAAAE,GAAAtJ,OAAAoJ,EAAAG,MAAAC,cAAA7I,EAAAlB,aAAAkB,EAAAA,EAAAlB,cAEA2J,EAAAE,GAAA1M,UAAAwM,EAAAG,MAAAC,cAAA7I,EAAA/D,UAAA+D,GAEAyI,EAAAE,GAAAzM,WAAAuM,EAAAG,MAAAC,cAAA7I,EAAA9D,WAAA8D,GAEAyI,EAAAE,GAAAhF,SAAA,SAAAgC,GACA,IAAAxJ,KAAAgL,OACA,OAAAhL,KAGA,GAAAwJ,EAKA,OAJAA,EAAAM,IAAAN,EAAAM,GAAAkB,UACAxB,EAAA3L,EAAA8O,MAAAnD,IACAM,GAAAN,EAAAM,GAAA,IAEA9J,KAAA6K,KAAA,WACAhH,EAAA0F,MAAAvJ,KAAAwJ,KAGA,IAAA2B,EAAAnL,KAAA,GAEA,OAAA6D,EAAAhE,iBAAAsL,IAKAmB,EAAAE,GAAApO,aAAAkO,EAAAG,MAAAG,YAAA/I,EAAAzF,aAAAyF,GAIAyI,EAAAE,GAAAtM,aAAAoM,EAAAG,MAAAC,cAAA7I,EAAA3D,aAAA2D,GAEAyI,EAAAE,GAAA9L,MAAA4L,EAAAG,MAAAC,cAAA7I,EAAAnD,MAAAmD,EAAAA,EAAAnD,OAEA4L,EAAAE,GAAA/L,OAAA6L,EAAAG,MAAAC,cAAA7I,EAAApD,OAAAoD,EAAAA,EAAApD,QAEA6L,EAAAE,GAAAlL,WAAAgL,EAAAG,MAAAC,cAAA7I,EAAAvC,WAAAuC,IAEA,QAAA,UAAAgJ,QAAA,SAAAlM,GACA,IAAAmM,EAAAnM,EAAAoM,QAAA,IAAA,SAAAC,GACA,OAAAA,EAAA,GAAAC,gBAGAX,EAAAE,GAAA,QAAAM,GAAA,SAAAI,EAAAxL,GAWA,GAVA4H,UAAA0B,OACA,kBAAAkC,IACAxL,EAAAwL,EACAA,GAAA,IAGAA,GAAA,EACAxL,OAAAtC,QAGAA,IAAAsC,EAAA,CACA,IAAAyL,EAAAnN,KAAA,GACA,IAAAmN,EACA,OAEA,IAAAC,EAAAvJ,EAAA3D,aAAAiN,GACA,GAAAD,EAAA,CACA,IAAAxI,EAAAb,EAAAlE,cAAAwN,GACAC,EAAA1M,MAAA0M,EAAA1M,MAAAgE,EAAAlG,KAAAkG,EAAAhG,MACA0O,EAAA3M,OAAA2M,EAAA3M,OAAAiE,EAAAjG,IAAAiG,EAAA/F,OAEA,MAAA,UAAAgC,EAAAyM,EAAA1M,MAAA0M,EAAA3M,OAEA,OAAAT,KAAA6K,KAAA,SAAAwC,EAAAF,GACA,IAAAG,KACA5I,EAAAb,EAAAlE,cAAAwN,GACA,UAAAxM,GACA2M,EAAA5M,MAAAgB,EACAwL,IACAI,EAAA5M,MAAA4M,EAAA5M,MAAAgE,EAAAlG,KAAAkG,EAAAhG,SAGA4O,EAAA7M,OAAAiB,EACAwL,IACAI,EAAA7M,OAAA6M,EAAA7M,OAAAiE,EAAAjG,IAAAiG,EAAA/F,SAGAkF,EAAA3D,aAAAiN,EAAAG,QAOAhB,EAAAE,GAAAhM,WAAA8L,EAAAG,MAAAC,cAAA7I,EAAAtC,YAAAsC,EAAAA,EAAAtC,aAEA+K,EAAAE,GAAAjM,YAAA+L,EAAAG,MAAAC,cAAA7I,EAAArC,aAAAqC,EAAAA,EAAArC,cAEAqC,IAEAlG,EAAA,qBAAA,0BAAA,SAAA4P,GAAA,OAAAA","file":"../skylark-domx-geom.js","sourcesContent":["define('skylark-domx-geom/geom',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\"\r\n], function(skylark, langx, noder, styler) {\r\n  'use strict'\r\n\r\n    var rootNodeRE = /^(?:body|html)$/i,\r\n        px = langx.toPixel,\r\n        offsetParent = noder.offsetParent,\r\n        cachedScrollbarWidth;\r\n\r\n    function scrollbarWidth() {\r\n        if (cachedScrollbarWidth !== undefined) {\r\n            return cachedScrollbarWidth;\r\n        }\r\n        var w1, w2,\r\n            div = noder.createFragment(\"<div style=\" +\r\n                \"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\r\n                \"<div style='height:300px;width:auto;'></div></div>\")[0],\r\n            innerDiv = div.childNodes[0];\r\n\r\n        noder.append(document.body, div);\r\n\r\n        w1 = innerDiv.offsetWidth;\r\n        styler.css(div, \"overflow\", \"scroll\");\r\n\r\n        w2 = innerDiv.offsetWidth;\r\n\r\n        if (w1 === w2) {\r\n            w2 = div[0].clientWidth;\r\n        }\r\n\r\n        noder.remove(div);\r\n\r\n        return (cachedScrollbarWidth = w1 - w2);\r\n    }\r\n\r\n\r\n    function hasScrollbar() {\r\n        return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight);\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each border of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function borderExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.borderLeftWidth, elm),\r\n            top: px(s.borderTopWidth, elm),\r\n            right: px(s.borderRightWidth, elm),\r\n            bottom: px(s.borderBottomWidth, elm)\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function boundingHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return boundingSize(elm).height;\r\n        } else {\r\n            boundingSize(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the viewport position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingPosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top + (scrollTop(parent) || 0),\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left + (scrollLeft(parent) || 0)\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the viewport rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            if (elm == window || elm == document.documentElement || elm == document.body){\r\n                return {\r\n                    top : 0,\r\n                    left : 0,\r\n                    bottom : window.innerHeight,\r\n                    right : window.innerWidth,\r\n                    height : window.innerHeight,\r\n                    width : window.innerWidth\r\n                };\r\n            } else if (elm.getBoundingClientRect) {\r\n                return elm.getBoundingClientRect();\r\n            }\r\n        } else {\r\n            boundingPosition(elm, coords);\r\n            boundingSize(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject}dimension\r\n     */\r\n    function boundingSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            if (langx.isWindow(elm)) {\r\n                return {\r\n                    width: elm.innerWidth,\r\n                    height: elm.innerHeight\r\n                }\r\n\r\n            } else if (langx.isDocument(elm)) {\r\n                return getDocumentSize(document);\r\n            } else {\r\n                return {\r\n                    width: elm.offsetWidth,\r\n                    height: elm.offsetHeight\r\n                }\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm),\r\n                    bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function boundingWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return boundingSize(elm).width;\r\n        } else {\r\n            boundingSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the height of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function clientHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).height;\r\n        } else {\r\n            return clientSize(elm, {\r\n                height: value\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            return {\r\n                width: elm.clientWidth || elm.innerWidth,\r\n                height: elm.clientHeight || elm.innerHeight\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width - pex.left - pex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height - pex.top - pex.bottom;\r\n                }\r\n            } else {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height + bex.top + bex.bottom;\r\n                }\r\n\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n        return {\r\n            width: elm.clientWidth,\r\n            height: elm.clientHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the width of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).width;\r\n        } else {\r\n            clientSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the height of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return contentSize(elm).height;\r\n        } else {\r\n            contentSize(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the rect of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentRect(elm) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n\r\n        //// On Opera, offsetLeft includes the parent's border\r\n        //if(has(\"opera\")){\r\n        //    pe.l += be.l;\r\n        //    pe.t += be.t;\r\n        //}\r\n        return {\r\n            left: pex.left,\r\n            top: pex.top,\r\n            width: cs.width - pex.left - pex.right,\r\n            height: cs.height - pex.top - pex.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentSize(elm,dimension) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n        if (dimension === undefined) {\r\n            return {\r\n                width: cs.width - pex.left - pex.right,\r\n                height: cs.height - pex.top - pex.bottom\r\n            };\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (isBorderBox) {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width + pex.left + pex.right + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height + pex.top + pex.bottom + bex.top + bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the width of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return contentSize(elm).width;\r\n        } else {\r\n            contentSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLDocument} doc\r\n     */\r\n    function getDocumentSize(doc) {\r\n        var documentElement = doc.documentElement,\r\n            body = doc.body,\r\n            max = Math.max,\r\n            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),\r\n            clientWidth = max(documentElement.clientWidth, body.clientWidth),\r\n            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),\r\n            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),\r\n            clientHeight = max(documentElement.clientHeight, body.clientHeight),\r\n            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n\r\n        return {\r\n            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n        };\r\n    }\r\n\r\n\r\n    function inview(elm, cushion) {\r\n        function calibrate(coords, cushion) {\r\n            var o = {};\r\n            cushion = +cushion || 0;\r\n            o.width = (o.right = coords.right + cushion) - (o.left = coords.left - cushion);\r\n            o.height = (o.bottom = coords.bottom + cushion) - (o.top = coords.top - cushion);\r\n            return o;\r\n        }\r\n\r\n        var r = calibrate(boundingRect(elm), cushion),\r\n            vsize = viewportSize();\r\n\r\n        return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= vsize.height && r.left <= vsize.width;\r\n    }\r\n\r\n\r\n    /*\r\n     * Get the widths of each margin of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function marginExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.marginLeft),\r\n            top: px(s.marginTop),\r\n            right: px(s.marginRight),\r\n            bottom: px(s.marginBottom),\r\n        }\r\n    }\r\n\r\n\r\n    function marginRect(elm) {\r\n        var obj = relativeRect(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            left: obj.left,\r\n            top: obj.top,\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function marginSize(elm) {\r\n        var obj = boundingSize(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each padding of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function paddingExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.paddingLeft),\r\n            top: px(s.paddingTop),\r\n            right: px(s.paddingRight),\r\n            bottom: px(s.paddingBottom),\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    //coordinate to the document\r\n    function pagePosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect(),\r\n                w = elm.ownerDocument.defaultView;\r\n            return {\r\n                left: obj.left + w.pageXOffset,\r\n                top: obj.top + w.pageYOffset\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = pagePosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function pageRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect(),\r\n                w = elm.ownerDocument.defaultView;\r\n            return {\r\n                left: obj.left + w.pageXOffset,\r\n                top: obj.top + w.pageYOffset,\r\n                width: Math.round(obj.width),\r\n                height: Math.round(obj.height)\r\n            }\r\n        } else {\r\n            pagePosition(elm, coords);\r\n            boundingSize(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the position of the specified element border box , relative to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    // coordinate relative to it's parent\r\n    function relativePosition(elm, coords) {\r\n        if (coords == undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingPosition(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left - mex.left\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm);\r\n\r\n            var props = {\r\n                top: coords.top,\r\n                left: coords.left\r\n            };\r\n\r\n            /*\r\n            if (langx.isDefined(props.top)) {\r\n                props.top = props.top + (scrollTop(parent) || 0);\r\n            }\r\n\r\n            if (langx.isDefined(props.left)) {\r\n                props.left = props.left + (scrollLeft(parent) || 0);\r\n            } \r\n            */ \r\n\r\n            if (styler.css(elm, \"position\") == \"static\") {\r\n                props['position'] = \"relative\";\r\n            }\r\n\r\n\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the rect of the specified element border box , relatived to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function relativeRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingRect(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left,\r\n                width: offset.width,\r\n                height: offset.height\r\n            }\r\n        } else {\r\n            relativePosition(elm, coords);\r\n            boundingSize(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Scroll the specified element into view.\r\n     * @param {HTMLElement} elm\r\n     * @param {} align\r\n     */\r\n    function scrollIntoView(elm, align) {\r\n        function getOffset(elm, rootElm) {\r\n            var x, y, parent = elm;\r\n\r\n            x = y = 0;\r\n            while (parent && parent != rootElm && parent.nodeType) {\r\n                x += parent.offsetLeft || 0;\r\n                y += parent.offsetTop || 0;\r\n                parent = parent.offsetParent;\r\n            }\r\n\r\n            return { x: x, y: y };\r\n        }\r\n\r\n        var parentElm = elm.parentNode;\r\n        var x, y, width, height, parentWidth, parentHeight;\r\n        var pos = getOffset(elm, parentElm);\r\n\r\n        x = pos.x;\r\n        y = pos.y;\r\n        width = elm.offsetWidth;\r\n        height = elm.offsetHeight;\r\n        parentWidth = parentElm.clientWidth;\r\n        parentHeight = parentElm.clientHeight;\r\n\r\n        if (align == \"end\") {\r\n            x -= parentWidth - width;\r\n            y -= parentHeight - height;\r\n        } else if (align == \"center\") {\r\n            x -= (parentWidth / 2) - (width / 2);\r\n            y -= (parentHeight / 2) - (height / 2);\r\n        }\r\n\r\n        parentElm.scrollLeft = x;\r\n        parentElm.scrollTop = y;\r\n\r\n        return this;\r\n    }\r\n    /*\r\n     * Get or set the current horizontal position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollLeft(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        } else if (elm == document.body) {\r\n            elm = document.scrollingElement  || document.documentElement;\r\n        }\r\n        var hasScrollLeft = \"scrollLeft\" in elm;\r\n        if (value === undefined) {\r\n            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset\r\n        } else {\r\n            if (hasScrollLeft) {\r\n                elm.scrollLeft = value;\r\n            } else {\r\n                elm.scrollTo(value, elm.scrollY);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or the current vertical position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollTop(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        } else if (elm == document.body) {\r\n            elm = document.scrollingElement  || document.documentElement;\r\n        }\r\n\r\n        var hasScrollTop = \"scrollTop\" in elm;\r\n\r\n        if (value === undefined) {\r\n            return hasScrollTop ? elm.scrollTop : elm.pageYOffset\r\n        } else {\r\n            if (hasScrollTop) {\r\n                elm.scrollTop = value;\r\n            } else {\r\n                elm.scrollTo(elm.scrollX, value);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    function scrollBy(elm, x, y) {\r\n        elm.scrollLeft += x;\r\n        elm.scrollTop += y;\r\n    }\r\n\r\n\r\n\r\n    function viewportSize(win) {\r\n        win = win || window;\r\n\r\n        return boundingRect(win);\r\n    }\r\n\r\n\r\n\r\n    function testAxis(elm) {\r\n       \r\n        var top = elm.offsetTop;\r\n        var left = elm.offsetLeft;\r\n        var width = elm.offsetWidth;\r\n        var height = elm.offsetHeight;\r\n\r\n        while(elm.offsetParent) {\r\n            elm = elm.offsetParent;\r\n            top += elm.offsetTop;\r\n            left += elm.offsetLeft;\r\n        }\r\n\r\n        var result = {x: 0, y: 0};\r\n\r\n        //Over the top of the window\r\n        if(top < window.pageYOffset) {\r\n            result.y = top - window.pageYOffset;\r\n        }\r\n        //Bellow the window\r\n        else if((top + height) > (window.pageYOffset + window.innerHeight))\r\n        {\r\n            result.y = (top + height) - (window.pageYOffset + window.innerHeight);\r\n        }\r\n\r\n        //Left to the window\r\n        if(left < window.pageXOffset) {\r\n            result.x = left - window.pageXOffset;\r\n        }\r\n        //Right to the window\r\n        else if((left + width) > (window.pageXOffset + window.innerWidth))\r\n        {\r\n            result.x = (left + width) - (window.pageXOffset + window.innerWidth);\r\n        }\r\n\r\n        return result;\r\n    };    \r\n\r\n    function geom() {\r\n        return geom;\r\n    }\r\n\r\n    langx.mixin(geom, {\r\n        borderExtents: borderExtents,\r\n\r\n        boundingHeight,\r\n        boundingPosition,\r\n        boundingRect,\r\n        boundingSize,\r\n        boundingWidth,\r\n\r\n        clientHeight,\r\n        clientSize,\r\n        clientWidth,\r\n\r\n        contentHeight,\r\n        contentRect,\r\n        contentSize,\r\n        contentWidth,\r\n\r\n        getDocumentSize: getDocumentSize,\r\n\r\n        hasScrollbar,\r\n\r\n        height: contentHeight,\r\n\r\n        inview,\r\n\r\n        marginExtents: marginExtents,\r\n\r\n        marginRect,\r\n        marginSize,\r\n\r\n        offsetParent: offsetParent,\r\n\r\n        paddingExtents: paddingExtents,\r\n\r\n        //coordinate to the document\r\n        pagePosition: pagePosition,\r\n\r\n        pageRect: pageRect,\r\n\r\n        // coordinate relative to it's parent\r\n        relativePosition: relativePosition,\r\n\r\n        relativeRect: relativeRect,\r\n\r\n        scrollbarWidth: scrollbarWidth,\r\n\r\n        scrollIntoView: scrollIntoView,\r\n\r\n        scrollLeft: scrollLeft,\r\n\r\n        scrollTop: scrollTop,\r\n\r\n        scrollBy,\r\n            \r\n        size: contentSize,\r\n\r\n        testAxis,\r\n\r\n        viewportSize,\r\n\r\n        width: contentWidth\r\n    });\r\n\r\n\r\n\r\n    return skylark.attach(\"domx.geom\", geom);\r\n});\ndefine('skylark-domx-geom/posit',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\",\r\n    \"./geom\"\r\n],function(langx,noder,styler,geom){\r\n  'use strict'\r\n\r\n    var max = Math.max,\r\n        abs = Math.abs,\r\n        rhorizontal = /left|center|right/,\r\n        rvertical = /top|center|bottom/,\r\n        roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\r\n        rposition = /^\\w+/,\r\n        rpercent = /%$/;\r\n\r\n    function getOffsets( offsets, width, height ) {\r\n        return [\r\n            parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\r\n            parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\r\n        ];\r\n    }\r\n\r\n    function parseCss( element, property ) {\r\n        return parseInt( styler.css( element, property ), 10 ) || 0;\r\n    }\r\n\r\n    function getDimensions( raw ) {\r\n        if ( raw.nodeType === 9 ) {\r\n            return {\r\n                size: size(raw),\r\n                offset: { top: 0, left: 0 }\r\n            };\r\n        }\r\n        if ( noder.isWindow( raw ) ) {\r\n            return {\r\n                size: geom.size(raw),\r\n                offset: { \r\n                    top: geom.scrollTop(raw), \r\n                    left: geom.scrollLeft(raw) \r\n                }\r\n            };\r\n        }\r\n        if ( raw.preventDefault ) {\r\n            return {\r\n                size : {\r\n                    width: 0,\r\n                    height: 0\r\n                },\r\n                offset: { \r\n                    top: raw.pageY, \r\n                    left: raw.pageX \r\n                }\r\n            };\r\n        }\r\n        return {\r\n            size: geom.size(raw),\r\n            offset: geom.pagePosition(raw)\r\n        };\r\n    }\r\n\r\n    function getScrollInfo( within ) {\r\n        var overflowX = within.isWindow || within.isDocument ? \"\" :\r\n                styler.css(within.element,\"overflow-x\" ),\r\n            overflowY = within.isWindow || within.isDocument ? \"\" :\r\n                styler.css(within.element,\"overflow-y\" ),\r\n            hasOverflowX = overflowX === \"scroll\" ||\r\n                ( overflowX === \"auto\" && within.width < geom.scrollWidth(within.element) ),\r\n            hasOverflowY = overflowY === \"scroll\" ||\r\n                ( overflowY === \"auto\" && within.height < geom.scrollHeight(within.element));\r\n        return {\r\n            width: hasOverflowY ? geom.scrollbarWidth() : 0,\r\n            height: hasOverflowX ? geom.scrollbarWidth() : 0\r\n        };\r\n    }\r\n\r\n    function getWithinInfo( element ) {\r\n        var withinElement = element || window,\r\n            isWindow = noder.isWindow( withinElement),\r\n            isDocument = !!withinElement && withinElement.nodeType === 9,\r\n            hasOffset = !isWindow && !isDocument,\r\n            msize = geom.marginSize(withinElement);\r\n        return {\r\n            element: withinElement,\r\n            isWindow: isWindow,\r\n            isDocument: isDocument,\r\n            offset: hasOffset ? geom.pagePosition(element) : { left: 0, top: 0 },\r\n            scrollLeft: geom.scrollLeft(withinElement),\r\n            scrollTop: geom.scrollTop(withinElement),\r\n            width: msize.width,\r\n            height: msize.height\r\n        };\r\n    }\r\n\r\n    function posit(elm,options ) {\r\n        // Make a copy, we don't want to modify arguments\r\n        options = langx.extend( {}, options );\r\n\r\n        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\r\n            target = options.of,\r\n            within = getWithinInfo( options.within ),\r\n            scrollInfo = getScrollInfo( within ),\r\n            collision = ( options.collision || \"flip\" ).split( \" \" ),\r\n            offsets = {};\r\n\r\n        dimensions = getDimensions( target );\r\n        if ( target.preventDefault ) {\r\n\r\n            // Force left top to allow flipping\r\n            options.at = \"left top\";\r\n        }\r\n        targetWidth = dimensions.size.width;\r\n        targetHeight = dimensions.size.height;\r\n        targetOffset = dimensions.offset;\r\n\r\n        // Clone to reuse original targetOffset later\r\n        basePosition = langx.extend( {}, targetOffset );\r\n\r\n        // Force my and at to have valid horizontal and vertical positions\r\n        // if a value is missing or invalid, it will be converted to center\r\n        langx.each( [ \"my\", \"at\" ], function() {\r\n            var pos = ( options[ this ] || \"\" ).split( \" \" ),\r\n                horizontalOffset,\r\n                verticalOffset;\r\n\r\n            if ( pos.length === 1 ) {\r\n                pos = rhorizontal.test( pos[ 0 ] ) ?\r\n                    pos.concat( [ \"center\" ] ) :\r\n                    rvertical.test( pos[ 0 ] ) ?\r\n                        [ \"center\" ].concat( pos ) :\r\n                        [ \"center\", \"center\" ];\r\n            }\r\n            pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\r\n            pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\r\n\r\n            // Calculate offsets\r\n            horizontalOffset = roffset.exec( pos[ 0 ] );\r\n            verticalOffset = roffset.exec( pos[ 1 ] );\r\n            offsets[ this ] = [\r\n                horizontalOffset ? horizontalOffset[ 0 ] : 0,\r\n                verticalOffset ? verticalOffset[ 0 ] : 0\r\n            ];\r\n\r\n            // Reduce to just the positions without the offsets\r\n            options[ this ] = [\r\n                rposition.exec( pos[ 0 ] )[ 0 ],\r\n                rposition.exec( pos[ 1 ] )[ 0 ]\r\n            ];\r\n        } );\r\n\r\n        // Normalize collision option\r\n        if ( collision.length === 1 ) {\r\n            collision[ 1 ] = collision[ 0 ];\r\n        }\r\n\r\n        if ( options.at[ 0 ] === \"right\" ) {\r\n            basePosition.left += targetWidth;\r\n        } else if ( options.at[ 0 ] === \"center\" ) {\r\n            basePosition.left += targetWidth / 2;\r\n        }\r\n\r\n        if ( options.at[ 1 ] === \"bottom\" ) {\r\n            basePosition.top += targetHeight;\r\n        } else if ( options.at[ 1 ] === \"center\" ) {\r\n            basePosition.top += targetHeight / 2;\r\n        }\r\n\r\n        atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\r\n        basePosition.left += atOffset[ 0 ];\r\n        basePosition.top += atOffset[ 1 ];\r\n\r\n        return ( function(elem) {\r\n            var collisionPosition, using,\r\n                msize = geom.marginSize(elem),\r\n                elemWidth = msize.width,\r\n                elemHeight = msize.height,\r\n                marginLeft = parseCss( elem, \"marginLeft\" ),\r\n                marginTop = parseCss( elem, \"marginTop\" ),\r\n                collisionWidth = elemWidth + marginLeft + parseCss( elem, \"marginRight\" ) +\r\n                    scrollInfo.width,\r\n                collisionHeight = elemHeight + marginTop + parseCss( elem, \"marginBottom\" ) +\r\n                    scrollInfo.height,\r\n                position = langx.extend( {}, basePosition ),\r\n                myOffset = getOffsets( offsets.my, msize.width, msize.height);\r\n\r\n            if ( options.my[ 0 ] === \"right\" ) {\r\n                position.left -= elemWidth;\r\n            } else if ( options.my[ 0 ] === \"center\" ) {\r\n                position.left -= elemWidth / 2;\r\n            }\r\n\r\n            if ( options.my[ 1 ] === \"bottom\" ) {\r\n                position.top -= elemHeight;\r\n            } else if ( options.my[ 1 ] === \"center\" ) {\r\n                position.top -= elemHeight / 2;\r\n            }\r\n\r\n            position.left += myOffset[ 0 ];\r\n            position.top += myOffset[ 1 ];\r\n\r\n            collisionPosition = {\r\n                marginLeft: marginLeft,\r\n                marginTop: marginTop\r\n            };\r\n\r\n            langx.each( [ \"left\", \"top\" ], function( i, dir ) {\r\n                if ( positions[ collision[ i ] ] ) {\r\n                    positions[ collision[ i ] ][ dir ]( position, {\r\n                        targetWidth: targetWidth,\r\n                        targetHeight: targetHeight,\r\n                        elemWidth: elemWidth,\r\n                        elemHeight: elemHeight,\r\n                        collisionPosition: collisionPosition,\r\n                        collisionWidth: collisionWidth,\r\n                        collisionHeight: collisionHeight,\r\n                        offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\r\n                        my: options.my,\r\n                        at: options.at,\r\n                        within: within,\r\n                        elem: elem\r\n                    } );\r\n                }\r\n            } );\r\n\r\n            if ( options.using ) {\r\n\r\n                // Adds feedback as second argument to using callback, if present\r\n                using = function( props ) {\r\n                    var left = targetOffset.left - position.left,\r\n                        right = left + targetWidth - elemWidth,\r\n                        top = targetOffset.top - position.top,\r\n                        bottom = top + targetHeight - elemHeight,\r\n                        feedback = {\r\n                            target: {\r\n                                element: target,\r\n                                left: targetOffset.left,\r\n                                top: targetOffset.top,\r\n                                width: targetWidth,\r\n                                height: targetHeight\r\n                            },\r\n                            element: {\r\n                                element: elem,\r\n                                left: position.left,\r\n                                top: position.top,\r\n                                width: elemWidth,\r\n                                height: elemHeight\r\n                            },\r\n                            horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\r\n                            vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\r\n                        };\r\n                    if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\r\n                        feedback.horizontal = \"center\";\r\n                    }\r\n                    if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\r\n                        feedback.vertical = \"middle\";\r\n                    }\r\n                    if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\r\n                        feedback.important = \"horizontal\";\r\n                    } else {\r\n                        feedback.important = \"vertical\";\r\n                    }\r\n                    options.using.call( this, props, feedback );\r\n                };\r\n            }\r\n\r\n            geom.pagePosition(elem, langx.extend( position, { using: using } ));\r\n        })(elm);\r\n    }\r\n\r\n    var positions = {\r\n        fit: {\r\n            left: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                    outerWidth = within.width,\r\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                    overLeft = withinOffset - collisionPosLeft,\r\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\r\n                    newOverRight;\r\n\r\n                // Element is wider than within\r\n                if ( data.collisionWidth > outerWidth ) {\r\n\r\n                    // Element is initially over the left side of within\r\n                    if ( overLeft > 0 && overRight <= 0 ) {\r\n                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\r\n                            withinOffset;\r\n                        position.left += overLeft - newOverRight;\r\n\r\n                    // Element is initially over right side of within\r\n                    } else if ( overRight > 0 && overLeft <= 0 ) {\r\n                        position.left = withinOffset;\r\n\r\n                    // Element is initially over both left and right sides of within\r\n                    } else {\r\n                        if ( overLeft > overRight ) {\r\n                            position.left = withinOffset + outerWidth - data.collisionWidth;\r\n                        } else {\r\n                            position.left = withinOffset;\r\n                        }\r\n                    }\r\n\r\n                // Too far left -> align with left edge\r\n                } else if ( overLeft > 0 ) {\r\n                    position.left += overLeft;\r\n\r\n                // Too far right -> align with right edge\r\n                } else if ( overRight > 0 ) {\r\n                    position.left -= overRight;\r\n\r\n                // Adjust based on position and margin\r\n                } else {\r\n                    position.left = max( position.left - collisionPosLeft, position.left );\r\n                }\r\n            },\r\n            top: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\r\n                    outerHeight = data.within.height,\r\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                    overTop = withinOffset - collisionPosTop,\r\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\r\n                    newOverBottom;\r\n\r\n                // Element is taller than within\r\n                if ( data.collisionHeight > outerHeight ) {\r\n\r\n                    // Element is initially over the top of within\r\n                    if ( overTop > 0 && overBottom <= 0 ) {\r\n                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\r\n                            withinOffset;\r\n                        position.top += overTop - newOverBottom;\r\n\r\n                    // Element is initially over bottom of within\r\n                    } else if ( overBottom > 0 && overTop <= 0 ) {\r\n                        position.top = withinOffset;\r\n\r\n                    // Element is initially over both top and bottom of within\r\n                    } else {\r\n                        if ( overTop > overBottom ) {\r\n                            position.top = withinOffset + outerHeight - data.collisionHeight;\r\n                        } else {\r\n                            position.top = withinOffset;\r\n                        }\r\n                    }\r\n\r\n                // Too far up -> align with top\r\n                } else if ( overTop > 0 ) {\r\n                    position.top += overTop;\r\n\r\n                // Too far down -> align with bottom edge\r\n                } else if ( overBottom > 0 ) {\r\n                    position.top -= overBottom;\r\n\r\n                // Adjust based on position and margin\r\n                } else {\r\n                    position.top = max( position.top - collisionPosTop, position.top );\r\n                }\r\n            }\r\n        },\r\n        flip: {\r\n            left: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.offset.left + within.scrollLeft,\r\n                    outerWidth = within.width,\r\n                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                    overLeft = collisionPosLeft - offsetLeft,\r\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\r\n                    myOffset = data.my[ 0 ] === \"left\" ?\r\n                        -data.elemWidth :\r\n                        data.my[ 0 ] === \"right\" ?\r\n                            data.elemWidth :\r\n                            0,\r\n                    atOffset = data.at[ 0 ] === \"left\" ?\r\n                        data.targetWidth :\r\n                        data.at[ 0 ] === \"right\" ?\r\n                            -data.targetWidth :\r\n                            0,\r\n                    offset = -2 * data.offset[ 0 ],\r\n                    newOverRight,\r\n                    newOverLeft;\r\n\r\n                if ( overLeft < 0 ) {\r\n                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\r\n                        outerWidth - withinOffset;\r\n                    if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\r\n                        position.left += myOffset + atOffset + offset;\r\n                    }\r\n                } else if ( overRight > 0 ) {\r\n                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\r\n                        atOffset + offset - offsetLeft;\r\n                    if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\r\n                        position.left += myOffset + atOffset + offset;\r\n                    }\r\n                }\r\n            },\r\n            top: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.offset.top + within.scrollTop,\r\n                    outerHeight = within.height,\r\n                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\r\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                    overTop = collisionPosTop - offsetTop,\r\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\r\n                    top = data.my[ 1 ] === \"top\",\r\n                    myOffset = top ?\r\n                        -data.elemHeight :\r\n                        data.my[ 1 ] === \"bottom\" ?\r\n                            data.elemHeight :\r\n                            0,\r\n                    atOffset = data.at[ 1 ] === \"top\" ?\r\n                        data.targetHeight :\r\n                        data.at[ 1 ] === \"bottom\" ?\r\n                            -data.targetHeight :\r\n                            0,\r\n                    offset = -2 * data.offset[ 1 ],\r\n                    newOverTop,\r\n                    newOverBottom;\r\n                if ( overTop < 0 ) {\r\n                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\r\n                        outerHeight - withinOffset;\r\n                    if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\r\n                        position.top += myOffset + atOffset + offset;\r\n                    }\r\n                } else if ( overBottom > 0 ) {\r\n                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\r\n                        offset - offsetTop;\r\n                    if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\r\n                        position.top += myOffset + atOffset + offset;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        flipfit: {\r\n            left: function() {\r\n                positions.flip.left.apply( this, arguments );\r\n                positions.fit.left.apply( this, arguments );\r\n            },\r\n            top: function() {\r\n                positions.flip.top.apply( this, arguments );\r\n                positions.fit.top.apply( this, arguments );\r\n            }\r\n        }\r\n    };\r\n\r\n    return geom.posit = posit;\r\n});\ndefine('skylark-domx-geom/scroll-to-top',[\r\n    \"skylark-langx\",\r\n    \"skylark-domx-styler\",\r\n    \"./geom\"\r\n],function(langx,styler,geom) {\r\n    /*   \r\n     * Set the vertical position of the scroll bar for an element.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} pos\r\n     * @param {Number or String} speed\r\n     * @param {Function} callback\r\n     */\r\n    function scrollToTop(elm, pos, speed, callback) {\r\n        var scrollFrom = parseInt(elm.scrollTop),\r\n            i = 0,\r\n            runEvery = 5, // run every 5ms\r\n            freq = speed * 1000 / runEvery,\r\n            scrollTo = parseInt(pos);\r\n\r\n        var interval = setInterval(function() {\r\n            i++;\r\n\r\n            if (i <= freq) elm.scrollTop = (scrollTo - scrollFrom) / freq * i + scrollFrom;\r\n\r\n            if (i >= freq + 1) {\r\n                clearInterval(interval);\r\n                if (callback) langx.debounce(callback, 1000)();\r\n            }\r\n        }, runEvery);\r\n\r\n        return this;\r\n    }\r\n\r\n    return geom.scrollToTop = scrollToTop;\r\n});\ndefine('skylark-domx-geom/main',[\r\n    \"skylark-langx/langx\",\r\n    \"./geom\",\r\n    \"skylark-domx-velm\",\r\n    \"skylark-domx-query\",\r\n    \"./posit\",\r\n    \"./scroll-to-top\"\r\n],function(langx,geom,velm,$){\r\n   // from ./geom\r\n    velm.delegate([\r\n        \"borderExtents\",\r\n        \"boundingPosition\",\r\n        \"boundingHeight\",\r\n        \"boundingRect\",\r\n        \"boundingSize\",\r\n        \"boundingWidth\",\r\n\r\n        \"clientHeight\",\r\n        \"clientSize\",\r\n        \"clientWidth\",\r\n\r\n        \"contentHeight\",\r\n        \"contentRect\",\r\n        \"contentSize\",\r\n        \"contentWidth\",\r\n\r\n///        \"height\",\r\n        \"marginExtents\",\r\n        \"marginRect\",\r\n        \"marginSize\",\r\n        \"offsetParent\",\r\n        \"paddingExtents\",\r\n        \"pagePosition\",\r\n        \"pageRect\",\r\n        \"relativePosition\",\r\n        \"relativeRect\",\r\n        \"scrollIntoView\",\r\n        \"scrollLeft\",\r\n        \"scrollTop\",\r\n///        \"pageSize\",\r\n///        \"width\"\r\n    ], geom,{\r\n///        \"pageSize\" : \"size\"\r\n    });\r\n\r\n    $.fn.offset = $.wraps.wrapper_value(geom.pagePosition, geom, geom.pagePosition);\r\n\r\n    $.fn.scrollTop = $.wraps.wrapper_value(geom.scrollTop, geom);\r\n\r\n    $.fn.scrollLeft = $.wraps.wrapper_value(geom.scrollLeft, geom);\r\n\r\n    $.fn.position =  function(options) {\r\n        if (!this.length) {\r\n            return this;\r\n        }\r\n\r\n        if (options) {\r\n            if (options.of && options.of.length) {\r\n                options = langx.clone(options);\r\n                options.of = options.of[0];\r\n            }\r\n            return this.each( function() {\r\n                geom.posit(this,options);\r\n            });\r\n        } else {\r\n            var elem = this[0];\r\n\r\n            return geom.relativePosition(elem);\r\n\r\n        }             \r\n    };\r\n\r\n    $.fn.offsetParent = $.wraps.wrapper_map(geom.offsetParent, geom);\r\n\r\n\r\n    ///$.fn.pageSize = $.wraps.wrapper_value(geom.size, geom);\r\n    $.fn.boundingSize = $.wraps.wrapper_value(geom.boundingSize, geom);\r\n\r\n    $.fn.width = $.wraps.wrapper_value(geom.width, geom, geom.width);\r\n\r\n    $.fn.height = $.wraps.wrapper_value(geom.height, geom, geom.height);\r\n\r\n    $.fn.clientSize = $.wraps.wrapper_value(geom.clientSize, geom);\r\n    \r\n    ['width', 'height'].forEach(function(dimension) {\r\n        var offset, Dimension = dimension.replace(/./, function(m) {\r\n            return m[0].toUpperCase()\r\n        });\r\n\r\n        $.fn['outer' + Dimension] = function(margin, value) {\r\n            if (arguments.length) {\r\n                if (typeof margin !== 'boolean') {\r\n                    value = margin;\r\n                    margin = false;\r\n                }\r\n            } else {\r\n                margin = false;\r\n                value = undefined;\r\n            }\r\n\r\n            if (value === undefined) {\r\n                var el = this[0];\r\n                if (!el) {\r\n                    return undefined;\r\n                }\r\n                var cb = geom.boundingSize(el);\r\n                if (margin) {\r\n                    var me = geom.marginExtents(el);\r\n                    cb.width = cb.width + me.left + me.right;\r\n                    cb.height = cb.height + me.top + me.bottom;\r\n                }\r\n                return dimension === \"width\" ? cb.width : cb.height;\r\n            } else {\r\n                return this.each(function(idx, el) {\r\n                    var mb = {};\r\n                    var me = geom.marginExtents(el);\r\n                    if (dimension === \"width\") {\r\n                        mb.width = value;\r\n                        if (margin) {\r\n                            mb.width = mb.width - me.left - me.right\r\n                        }\r\n                    } else {\r\n                        mb.height = value;\r\n                        if (margin) {\r\n                            mb.height = mb.height - me.top - me.bottom;\r\n                        }\r\n                    }\r\n                    geom.boundingSize(el, mb);\r\n                })\r\n\r\n            }\r\n        };\r\n    })\r\n\r\n    $.fn.innerWidth = $.wraps.wrapper_value(geom.clientWidth, geom, geom.clientWidth);\r\n\r\n    $.fn.innerHeight = $.wraps.wrapper_value(geom.clientHeight, geom, geom.clientHeight);\r\n\r\n    return geom;\r\n});\ndefine('skylark-domx-geom', ['skylark-domx-geom/main'], function (main) { return main; });\n\n"]}