{"version":3,"sources":["skylark-domx-geom.js"],"names":["define","skylark","langx","noder","styler","cachedScrollbarWidth","rootNodeRE","px","toPixel","offsetParent","scrollbarWidth","undefined","w1","w2","div","createFragment","innerDiv","childNodes","append","document","body","offsetWidth","css","clientWidth","remove","borderExtents","elm","isWindow","left","top","right","bottom","s","getComputedStyle","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","boundingPosition","coords","test","nodeName","getBoundingClientRect","parent","parentOffset","mex","marginExtents","pbex","relativePosition","this","boundingRect","size","clientSize","dimension","width","height","clientHeight","isBorderBox","props","bex","pex","paddingExtents","getDocumentSize","doc","documentElement","max","Math","scrollWidth","scrollHeight","offsetHeight","marginLeft","marginTop","marginRight","marginBottom","marginSize","obj","me","paddingLeft","paddingTop","paddingRight","paddingBottom","pagePosition","window","pageXOffset","pageYOffset","offset","relativeRect","scrollLeft","value","nodeType","defaultView","hasScrollLeft","scrollTo","scrollY","scrollTop","hasScrollTop","scrollX","innerWidth","innerHeight","isDocument","geom","mixin","contentRect","cs","fullCover","elem","hor","vert","vertical","horizontal","isUndefined","style","position","isVisible","offsetTop","offsetLeft","marginRect","pageRect","round","scrollIntoView","align","x","y","parentWidth","parentHeight","parentElm","parentNode","pos","rootElm","getOffset","testAxis","result","abs","rhorizontal","rvertical","roffset","rposition","rpercent","getOffsets","offsets","parseFloat","parseCss","element","property","parseInt","positions","fit","data","newOverRight","within","withinOffset","outerWidth","collisionPosLeft","collisionPosition","overLeft","overRight","collisionWidth","newOverBottom","outerHeight","collisionPosTop","overTop","overBottom","collisionHeight","flip","newOverLeft","myOffset","my","elemWidth","atOffset","at","targetWidth","newOverTop","elemHeight","targetHeight","flipfit","apply","arguments","posit","options","targetOffset","basePosition","dimensions","target","extend","of","withinElement","hasOffset","msize","scrollInfo","overflowX","overflowY","hasOverflowX","getScrollInfo","collision","split","raw","preventDefault","pageY","pageX","each","horizontalOffset","verticalOffset","length","concat","exec","using","i","dir","feedback","important","call","attach","velm","$","delegate","fn","wraps","wrapper_value","clone","wrapper_map","forEach","Dimension","replace","m","toUpperCase","margin","el","cb","idx","mb","main"],"mappings":"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","file":"../skylark-domx-geom.js","sourcesContent":["define('skylark-domx-geom/geom',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\"\r\n], function(skylark, langx, noder, styler) {\r\n    var rootNodeRE = /^(?:body|html)$/i,\r\n        px = langx.toPixel,\r\n        offsetParent = noder.offsetParent,\r\n        cachedScrollbarWidth;\r\n\r\n    function scrollbarWidth() {\r\n        if (cachedScrollbarWidth !== undefined) {\r\n            return cachedScrollbarWidth;\r\n        }\r\n        var w1, w2,\r\n            div = noder.createFragment(\"<div style=\" +\r\n                \"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\r\n                \"<div style='height:300px;width:auto;'></div></div>\")[0],\r\n            innerDiv = div.childNodes[0];\r\n\r\n        noder.append(document.body, div);\r\n\r\n        w1 = innerDiv.offsetWidth;\r\n\r\n        styler.css(div, \"overflow\", \"scroll\");\r\n\r\n        w2 = innerDiv.offsetWidth;\r\n\r\n        if (w1 === w2) {\r\n            w2 = div[0].clientWidth;\r\n        }\r\n\r\n        noder.remove(div);\r\n\r\n        return (cachedScrollbarWidth = w1 - w2);\r\n    }\r\n    /*\r\n     * Get the widths of each border of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function borderExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.borderLeftWidth, elm),\r\n            top: px(s.borderTopWidth, elm),\r\n            right: px(s.borderRightWidth, elm),\r\n            bottom: px(s.borderBottomWidth, elm)\r\n        }\r\n    }\r\n\r\n\r\n    //viewport coordinate\r\n    /*\r\n     * Get or set the viewport position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingPosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the viewport rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            return elm.getBoundingClientRect()\r\n        } else {\r\n            boundingPosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the height of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function clientHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).height;\r\n        } else {\r\n            return clientSize(elm, {\r\n                height: value\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            return {\r\n                width: elm.clientWidth,\r\n                height: elm.clientHeight\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width - pex.left - pex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height - pex.top - pex.bottom;\r\n                }\r\n            } else {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height + bex.top + bex.bottom;\r\n                }\r\n\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n        return {\r\n            width: elm.clientWidth,\r\n            height: elm.clientHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the width of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).width;\r\n        } else {\r\n            clientSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the rect of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentRect(elm) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n\r\n        //// On Opera, offsetLeft includes the parent's border\r\n        //if(has(\"opera\")){\r\n        //    pe.l += be.l;\r\n        //    pe.t += be.t;\r\n        //}\r\n        return {\r\n            left: pex.left,\r\n            top: pex.top,\r\n            width: cs.width - pex.left - pex.right,\r\n            height: cs.height - pex.top - pex.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function fullCover(elem, hor, vert) {\r\n        let vertical = vert;\r\n        let horizontal = hor;\r\n        if (langx.isUndefined(horizontal)) {\r\n            horizontal = true;\r\n        }\r\n        if (langx.isUndefined(vertical)) {\r\n            vertical = true;\r\n        }\r\n        elem.style.position = 'absolute';\r\n        if (horizontal) {\r\n            elem.style.left = 0;\r\n            elem.style.right = 0;\r\n        }\r\n        if (vertical) {\r\n            elem.style.top = 0;\r\n            elem.style.bottom = 0;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLDocument} doc\r\n     */\r\n    function getDocumentSize(doc) {\r\n        var documentElement = doc.documentElement,\r\n            body = doc.body,\r\n            max = Math.max,\r\n            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),\r\n            clientWidth = max(documentElement.clientWidth, body.clientWidth),\r\n            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),\r\n            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),\r\n            clientHeight = max(documentElement.clientHeight, body.clientHeight),\r\n            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n\r\n        return {\r\n            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function height(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).height;\r\n        } else {\r\n            size(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a DOM element in completely visible in the viewport\r\n     *\r\n     * @method isVisible\r\n     * @param {DOM} elm DOM element to test.\r\n     * @return {Boolean} True if the element is inside of the browser viewport.\r\n     */\r\n    function isVisible(elm)   {\r\n        var top = elm.offsetTop;\r\n        var left = elm.offsetLeft;\r\n        var width = elm.offsetWidth;\r\n        var height = elm.offsetHeight;\r\n\r\n        while(elm.offsetParent)  {\r\n            elm = elm.offsetParent;\r\n            top += elm.offsetTop;\r\n            left += elm.offsetLeft;\r\n        }\r\n\r\n        return value = top >= window.pageYOffset && \r\n                       left >= window.pageXOffset && \r\n                       (top + height) <= (window.pageYOffset + window.innerHeight) && \r\n                       (left + width) <= (window.pageXOffset + window.innerWidth);\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each margin of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function marginExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.marginLeft),\r\n            top: px(s.marginTop),\r\n            right: px(s.marginRight),\r\n            bottom: px(s.marginBottom),\r\n        }\r\n    }\r\n\r\n\r\n    function marginRect(elm) {\r\n        var obj = relativeRect(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            left: obj.left,\r\n            top: obj.top,\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function marginSize(elm) {\r\n        var obj = size(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each padding of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function paddingExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.paddingLeft),\r\n            top: px(s.paddingTop),\r\n            right: px(s.paddingRight),\r\n            bottom: px(s.paddingBottom),\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    //coordinate to the document\r\n    function pagePosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = pagePosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function pageRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset,\r\n                width: Math.round(obj.width),\r\n                height: Math.round(obj.height)\r\n            }\r\n        } else {\r\n            pagePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the position of the specified element border box , relative to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    // coordinate relative to it's parent\r\n    function relativePosition(elm, coords) {\r\n        if (coords == undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingPosition(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left\r\n            }\r\n        } else {\r\n            var props = {\r\n                top: coords.top,\r\n                left: coords.left\r\n            }\r\n\r\n            if (styler.css(elm, \"position\") == \"static\") {\r\n                props['position'] = \"relative\";\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the rect of the specified element border box , relatived to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function relativeRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingRect(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left,\r\n                width: offset.width,\r\n                height: offset.height\r\n            }\r\n        } else {\r\n            relativePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Scroll the specified element into view.\r\n     * @param {HTMLElement} elm\r\n     * @param {} align\r\n     */\r\n    function scrollIntoView(elm, align) {\r\n        function getOffset(elm, rootElm) {\r\n            var x, y, parent = elm;\r\n\r\n            x = y = 0;\r\n            while (parent && parent != rootElm && parent.nodeType) {\r\n                x += parent.offsetLeft || 0;\r\n                y += parent.offsetTop || 0;\r\n                parent = parent.offsetParent;\r\n            }\r\n\r\n            return { x: x, y: y };\r\n        }\r\n\r\n        var parentElm = elm.parentNode;\r\n        var x, y, width, height, parentWidth, parentHeight;\r\n        var pos = getOffset(elm, parentElm);\r\n\r\n        x = pos.x;\r\n        y = pos.y;\r\n        width = elm.offsetWidth;\r\n        height = elm.offsetHeight;\r\n        parentWidth = parentElm.clientWidth;\r\n        parentHeight = parentElm.clientHeight;\r\n\r\n        if (align == \"end\") {\r\n            x -= parentWidth - width;\r\n            y -= parentHeight - height;\r\n        } else if (align == \"center\") {\r\n            x -= (parentWidth / 2) - (width / 2);\r\n            y -= (parentHeight / 2) - (height / 2);\r\n        }\r\n\r\n        parentElm.scrollLeft = x;\r\n        parentElm.scrollTop = y;\r\n\r\n        return this;\r\n    }\r\n    /*\r\n     * Get or set the current horizontal position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollLeft(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        }\r\n        var hasScrollLeft = \"scrollLeft\" in elm;\r\n        if (value === undefined) {\r\n            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset\r\n        } else {\r\n            if (hasScrollLeft) {\r\n                elm.scrollLeft = value;\r\n            } else {\r\n                elm.scrollTo(value, elm.scrollY);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or the current vertical position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollTop(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        }\r\n        var hasScrollTop = \"scrollTop\" in elm;\r\n\r\n        if (value === undefined) {\r\n            return hasScrollTop ? elm.scrollTop : elm.pageYOffset\r\n        } else {\r\n            if (hasScrollTop) {\r\n                elm.scrollTop = value;\r\n            } else {\r\n                elm.scrollTo(elm.scrollX, value);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject}dimension\r\n     */\r\n    function size(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            if (langx.isWindow(elm)) {\r\n                return {\r\n                    width: elm.innerWidth,\r\n                    height: elm.innerHeight\r\n                }\r\n\r\n            } else if (langx.isDocument(elm)) {\r\n                return getDocumentSize(document);\r\n            } else {\r\n                return {\r\n                    width: elm.offsetWidth,\r\n                    height: elm.offsetHeight\r\n                }\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm),\r\n                    bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function width(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).width;\r\n        } else {\r\n            size(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a DOM element is out of the window and how far it is, returns object with x and y values.\r\n     * \r\n     * If the value is 0 the element is inside the window on that axis.\r\n     *\r\n     * @method testAxis\r\n     * @param {DOM} elm DOM element to test.\r\n     * @return {Vector2} Distance outside of the viewport.\r\n     */\r\n    function testAxis(elm) {\r\n        var top = elm.offsetTop;\r\n        var left = elm.offsetLeft;\r\n        var width = elm.offsetWidth;\r\n        var height = elm.offsetHeight;\r\n\r\n        while(elm.offsetParent) {\r\n            elm = elm.offsetParent;\r\n            top += elm.offsetTop;\r\n            left += elm.offsetLeft;\r\n        }\r\n\r\n        var result = {x: 0, y: 0};\r\n\r\n        //Over the top of the window\r\n        if(top < window.pageYOffset) {\r\n            result.y = top - window.pageYOffset;\r\n        }\r\n        //Bellow the window\r\n        else if((top + height) > (window.pageYOffset + window.innerHeight))\r\n        {\r\n            result.y = (top + height) - (window.pageYOffset + window.innerHeight);\r\n        }\r\n\r\n        //Left to the window\r\n        if(left < window.pageXOffset) {\r\n            result.x = left - window.pageXOffset;\r\n        }\r\n        //Right to the window\r\n        else if((left + width) > (window.pageXOffset + window.innerWidth))\r\n        {\r\n            result.x = (left + width) - (window.pageXOffset + window.innerWidth);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    function geom() {\r\n        return geom;\r\n    }\r\n\r\n    langx.mixin(geom, {\r\n        borderExtents: borderExtents,\r\n        //viewport coordinate\r\n        boundingPosition: boundingPosition,\r\n\r\n        boundingRect: boundingRect,\r\n\r\n        clientHeight: clientHeight,\r\n\r\n        clientSize: clientSize,\r\n\r\n        clientWidth: clientWidth,\r\n\r\n        contentRect: contentRect,\r\n\r\n        fullCover,\r\n\r\n        getDocumentSize: getDocumentSize,\r\n\r\n        height: height,\r\n\r\n        isVisible,\r\n\r\n        marginExtents: marginExtents,\r\n\r\n        marginRect: marginRect,\r\n\r\n        marginSize: marginSize,\r\n\r\n        offsetParent: offsetParent,\r\n\r\n        paddingExtents: paddingExtents,\r\n\r\n        //coordinate to the document\r\n        pagePosition: pagePosition,\r\n\r\n        pageRect: pageRect,\r\n\r\n        // coordinate relative to it's parent\r\n        relativePosition: relativePosition,\r\n\r\n        relativeRect: relativeRect,\r\n\r\n        scrollbarWidth: scrollbarWidth,\r\n\r\n        scrollIntoView: scrollIntoView,\r\n\r\n        scrollLeft: scrollLeft,\r\n\r\n        scrollTop: scrollTop,\r\n\r\n        size: size,\r\n\r\n        testAxis,\r\n\r\n        width: width\r\n    });\r\n\r\n\r\n    /*\r\n     * Position an element relative to the window, document, another element, or the cursor/mouse.\r\n     * see https://jqueryui.com/position/\r\n     */\r\n    ( function() {\r\n        var max = Math.max,\r\n            abs = Math.abs,\r\n            rhorizontal = /left|center|right/,\r\n            rvertical = /top|center|bottom/,\r\n            roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\r\n            rposition = /^\\w+/,\r\n            rpercent = /%$/;\r\n\r\n        function getOffsets( offsets, width, height ) {\r\n            return [\r\n                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\r\n                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\r\n            ];\r\n        }\r\n\r\n        function parseCss( element, property ) {\r\n            return parseInt( styler.css( element, property ), 10 ) || 0;\r\n        }\r\n\r\n        function getDimensions( raw ) {\r\n            if ( raw.nodeType === 9 ) {\r\n                return {\r\n                    size: size(raw),\r\n                    offset: { top: 0, left: 0 }\r\n                };\r\n            }\r\n            if ( noder.isWindow( raw ) ) {\r\n                return {\r\n                    size: size(raw),\r\n                    offset: { \r\n                        top: scrollTop(raw), \r\n                        left: scrollLeft(raw) \r\n                    }\r\n                };\r\n            }\r\n            if ( raw.preventDefault ) {\r\n                return {\r\n                    size : {\r\n                        width: 0,\r\n                        height: 0\r\n                    },\r\n                    offset: { \r\n                        top: raw.pageY, \r\n                        left: raw.pageX \r\n                    }\r\n                };\r\n            }\r\n            return {\r\n                size: size(raw),\r\n                offset: pagePosition(raw)\r\n            };\r\n        }\r\n\r\n        function getScrollInfo( within ) {\r\n            var overflowX = within.isWindow || within.isDocument ? \"\" :\r\n                    styler.css(within.element,\"overflow-x\" ),\r\n                overflowY = within.isWindow || within.isDocument ? \"\" :\r\n                    styler.css(within.element,\"overflow-y\" ),\r\n                hasOverflowX = overflowX === \"scroll\" ||\r\n                    ( overflowX === \"auto\" && within.width < scrollWidth(within.element) ),\r\n                hasOverflowY = overflowY === \"scroll\" ||\r\n                    ( overflowY === \"auto\" && within.height < scrollHeight(within.element));\r\n            return {\r\n                width: hasOverflowY ? scrollbarWidth() : 0,\r\n                height: hasOverflowX ? scrollbarWidth() : 0\r\n            };\r\n        }\r\n\r\n        function getWithinInfo( element ) {\r\n            var withinElement = element || window,\r\n                isWindow = noder.isWindow( withinElement),\r\n                isDocument = !!withinElement && withinElement.nodeType === 9,\r\n                hasOffset = !isWindow && !isDocument,\r\n                msize = marginSize(withinElement);\r\n            return {\r\n                element: withinElement,\r\n                isWindow: isWindow,\r\n                isDocument: isDocument,\r\n                offset: hasOffset ? pagePosition(element) : { left: 0, top: 0 },\r\n                scrollLeft: scrollLeft(withinElement),\r\n                scrollTop: scrollTop(withinElement),\r\n                width: msize.width,\r\n                height: msize.height\r\n            };\r\n        }\r\n\r\n        function posit(elm,options ) {\r\n            // Make a copy, we don't want to modify arguments\r\n            options = langx.extend( {}, options );\r\n\r\n            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\r\n                target = options.of,\r\n                within = getWithinInfo( options.within ),\r\n                scrollInfo = getScrollInfo( within ),\r\n                collision = ( options.collision || \"flip\" ).split( \" \" ),\r\n                offsets = {};\r\n\r\n            dimensions = getDimensions( target );\r\n            if ( target.preventDefault ) {\r\n\r\n                // Force left top to allow flipping\r\n                options.at = \"left top\";\r\n            }\r\n            targetWidth = dimensions.size.width;\r\n            targetHeight = dimensions.size.height;\r\n            targetOffset = dimensions.offset;\r\n\r\n            // Clone to reuse original targetOffset later\r\n            basePosition = langx.extend( {}, targetOffset );\r\n\r\n            // Force my and at to have valid horizontal and vertical positions\r\n            // if a value is missing or invalid, it will be converted to center\r\n            langx.each( [ \"my\", \"at\" ], function() {\r\n                var pos = ( options[ this ] || \"\" ).split( \" \" ),\r\n                    horizontalOffset,\r\n                    verticalOffset;\r\n\r\n                if ( pos.length === 1 ) {\r\n                    pos = rhorizontal.test( pos[ 0 ] ) ?\r\n                        pos.concat( [ \"center\" ] ) :\r\n                        rvertical.test( pos[ 0 ] ) ?\r\n                            [ \"center\" ].concat( pos ) :\r\n                            [ \"center\", \"center\" ];\r\n                }\r\n                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\r\n                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\r\n\r\n                // Calculate offsets\r\n                horizontalOffset = roffset.exec( pos[ 0 ] );\r\n                verticalOffset = roffset.exec( pos[ 1 ] );\r\n                offsets[ this ] = [\r\n                    horizontalOffset ? horizontalOffset[ 0 ] : 0,\r\n                    verticalOffset ? verticalOffset[ 0 ] : 0\r\n                ];\r\n\r\n                // Reduce to just the positions without the offsets\r\n                options[ this ] = [\r\n                    rposition.exec( pos[ 0 ] )[ 0 ],\r\n                    rposition.exec( pos[ 1 ] )[ 0 ]\r\n                ];\r\n            } );\r\n\r\n            // Normalize collision option\r\n            if ( collision.length === 1 ) {\r\n                collision[ 1 ] = collision[ 0 ];\r\n            }\r\n\r\n            if ( options.at[ 0 ] === \"right\" ) {\r\n                basePosition.left += targetWidth;\r\n            } else if ( options.at[ 0 ] === \"center\" ) {\r\n                basePosition.left += targetWidth / 2;\r\n            }\r\n\r\n            if ( options.at[ 1 ] === \"bottom\" ) {\r\n                basePosition.top += targetHeight;\r\n            } else if ( options.at[ 1 ] === \"center\" ) {\r\n                basePosition.top += targetHeight / 2;\r\n            }\r\n\r\n            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\r\n            basePosition.left += atOffset[ 0 ];\r\n            basePosition.top += atOffset[ 1 ];\r\n\r\n            return ( function(elem) {\r\n                var collisionPosition, using,\r\n                    msize = marginSize(elem),\r\n                    elemWidth = msize.width,\r\n                    elemHeight = msize.height,\r\n                    marginLeft = parseCss( elem, \"marginLeft\" ),\r\n                    marginTop = parseCss( elem, \"marginTop\" ),\r\n                    collisionWidth = elemWidth + marginLeft + parseCss( elem, \"marginRight\" ) +\r\n                        scrollInfo.width,\r\n                    collisionHeight = elemHeight + marginTop + parseCss( elem, \"marginBottom\" ) +\r\n                        scrollInfo.height,\r\n                    position = langx.extend( {}, basePosition ),\r\n                    myOffset = getOffsets( offsets.my, msize.width, msize.height);\r\n\r\n                if ( options.my[ 0 ] === \"right\" ) {\r\n                    position.left -= elemWidth;\r\n                } else if ( options.my[ 0 ] === \"center\" ) {\r\n                    position.left -= elemWidth / 2;\r\n                }\r\n\r\n                if ( options.my[ 1 ] === \"bottom\" ) {\r\n                    position.top -= elemHeight;\r\n                } else if ( options.my[ 1 ] === \"center\" ) {\r\n                    position.top -= elemHeight / 2;\r\n                }\r\n\r\n                position.left += myOffset[ 0 ];\r\n                position.top += myOffset[ 1 ];\r\n\r\n                collisionPosition = {\r\n                    marginLeft: marginLeft,\r\n                    marginTop: marginTop\r\n                };\r\n\r\n                langx.each( [ \"left\", \"top\" ], function( i, dir ) {\r\n                    if ( positions[ collision[ i ] ] ) {\r\n                        positions[ collision[ i ] ][ dir ]( position, {\r\n                            targetWidth: targetWidth,\r\n                            targetHeight: targetHeight,\r\n                            elemWidth: elemWidth,\r\n                            elemHeight: elemHeight,\r\n                            collisionPosition: collisionPosition,\r\n                            collisionWidth: collisionWidth,\r\n                            collisionHeight: collisionHeight,\r\n                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\r\n                            my: options.my,\r\n                            at: options.at,\r\n                            within: within,\r\n                            elem: elem\r\n                        } );\r\n                    }\r\n                } );\r\n\r\n                if ( options.using ) {\r\n\r\n                    // Adds feedback as second argument to using callback, if present\r\n                    using = function( props ) {\r\n                        var left = targetOffset.left - position.left,\r\n                            right = left + targetWidth - elemWidth,\r\n                            top = targetOffset.top - position.top,\r\n                            bottom = top + targetHeight - elemHeight,\r\n                            feedback = {\r\n                                target: {\r\n                                    element: target,\r\n                                    left: targetOffset.left,\r\n                                    top: targetOffset.top,\r\n                                    width: targetWidth,\r\n                                    height: targetHeight\r\n                                },\r\n                                element: {\r\n                                    element: elem,\r\n                                    left: position.left,\r\n                                    top: position.top,\r\n                                    width: elemWidth,\r\n                                    height: elemHeight\r\n                                },\r\n                                horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\r\n                                vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\r\n                            };\r\n                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\r\n                            feedback.horizontal = \"center\";\r\n                        }\r\n                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\r\n                            feedback.vertical = \"middle\";\r\n                        }\r\n                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\r\n                            feedback.important = \"horizontal\";\r\n                        } else {\r\n                            feedback.important = \"vertical\";\r\n                        }\r\n                        options.using.call( this, props, feedback );\r\n                    };\r\n                }\r\n\r\n                pagePosition(elem, langx.extend( position, { using: using } ));\r\n            })(elm);\r\n        }\r\n\r\n        var positions = {\r\n            fit: {\r\n                left: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                        outerWidth = within.width,\r\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                        overLeft = withinOffset - collisionPosLeft,\r\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\r\n                        newOverRight;\r\n\r\n                    // Element is wider than within\r\n                    if ( data.collisionWidth > outerWidth ) {\r\n\r\n                        // Element is initially over the left side of within\r\n                        if ( overLeft > 0 && overRight <= 0 ) {\r\n                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\r\n                                withinOffset;\r\n                            position.left += overLeft - newOverRight;\r\n\r\n                        // Element is initially over right side of within\r\n                        } else if ( overRight > 0 && overLeft <= 0 ) {\r\n                            position.left = withinOffset;\r\n\r\n                        // Element is initially over both left and right sides of within\r\n                        } else {\r\n                            if ( overLeft > overRight ) {\r\n                                position.left = withinOffset + outerWidth - data.collisionWidth;\r\n                            } else {\r\n                                position.left = withinOffset;\r\n                            }\r\n                        }\r\n\r\n                    // Too far left -> align with left edge\r\n                    } else if ( overLeft > 0 ) {\r\n                        position.left += overLeft;\r\n\r\n                    // Too far right -> align with right edge\r\n                    } else if ( overRight > 0 ) {\r\n                        position.left -= overRight;\r\n\r\n                    // Adjust based on position and margin\r\n                    } else {\r\n                        position.left = max( position.left - collisionPosLeft, position.left );\r\n                    }\r\n                },\r\n                top: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\r\n                        outerHeight = data.within.height,\r\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                        overTop = withinOffset - collisionPosTop,\r\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\r\n                        newOverBottom;\r\n\r\n                    // Element is taller than within\r\n                    if ( data.collisionHeight > outerHeight ) {\r\n\r\n                        // Element is initially over the top of within\r\n                        if ( overTop > 0 && overBottom <= 0 ) {\r\n                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\r\n                                withinOffset;\r\n                            position.top += overTop - newOverBottom;\r\n\r\n                        // Element is initially over bottom of within\r\n                        } else if ( overBottom > 0 && overTop <= 0 ) {\r\n                            position.top = withinOffset;\r\n\r\n                        // Element is initially over both top and bottom of within\r\n                        } else {\r\n                            if ( overTop > overBottom ) {\r\n                                position.top = withinOffset + outerHeight - data.collisionHeight;\r\n                            } else {\r\n                                position.top = withinOffset;\r\n                            }\r\n                        }\r\n\r\n                    // Too far up -> align with top\r\n                    } else if ( overTop > 0 ) {\r\n                        position.top += overTop;\r\n\r\n                    // Too far down -> align with bottom edge\r\n                    } else if ( overBottom > 0 ) {\r\n                        position.top -= overBottom;\r\n\r\n                    // Adjust based on position and margin\r\n                    } else {\r\n                        position.top = max( position.top - collisionPosTop, position.top );\r\n                    }\r\n                }\r\n            },\r\n            flip: {\r\n                left: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.offset.left + within.scrollLeft,\r\n                        outerWidth = within.width,\r\n                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                        overLeft = collisionPosLeft - offsetLeft,\r\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\r\n                        myOffset = data.my[ 0 ] === \"left\" ?\r\n                            -data.elemWidth :\r\n                            data.my[ 0 ] === \"right\" ?\r\n                                data.elemWidth :\r\n                                0,\r\n                        atOffset = data.at[ 0 ] === \"left\" ?\r\n                            data.targetWidth :\r\n                            data.at[ 0 ] === \"right\" ?\r\n                                -data.targetWidth :\r\n                                0,\r\n                        offset = -2 * data.offset[ 0 ],\r\n                        newOverRight,\r\n                        newOverLeft;\r\n\r\n                    if ( overLeft < 0 ) {\r\n                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\r\n                            outerWidth - withinOffset;\r\n                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\r\n                            position.left += myOffset + atOffset + offset;\r\n                        }\r\n                    } else if ( overRight > 0 ) {\r\n                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\r\n                            atOffset + offset - offsetLeft;\r\n                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\r\n                            position.left += myOffset + atOffset + offset;\r\n                        }\r\n                    }\r\n                },\r\n                top: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.offset.top + within.scrollTop,\r\n                        outerHeight = within.height,\r\n                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\r\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                        overTop = collisionPosTop - offsetTop,\r\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\r\n                        top = data.my[ 1 ] === \"top\",\r\n                        myOffset = top ?\r\n                            -data.elemHeight :\r\n                            data.my[ 1 ] === \"bottom\" ?\r\n                                data.elemHeight :\r\n                                0,\r\n                        atOffset = data.at[ 1 ] === \"top\" ?\r\n                            data.targetHeight :\r\n                            data.at[ 1 ] === \"bottom\" ?\r\n                                -data.targetHeight :\r\n                                0,\r\n                        offset = -2 * data.offset[ 1 ],\r\n                        newOverTop,\r\n                        newOverBottom;\r\n                    if ( overTop < 0 ) {\r\n                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\r\n                            outerHeight - withinOffset;\r\n                        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\r\n                            position.top += myOffset + atOffset + offset;\r\n                        }\r\n                    } else if ( overBottom > 0 ) {\r\n                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\r\n                            offset - offsetTop;\r\n                        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\r\n                            position.top += myOffset + atOffset + offset;\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            flipfit: {\r\n                left: function() {\r\n                    positions.flip.left.apply( this, arguments );\r\n                    positions.fit.left.apply( this, arguments );\r\n                },\r\n                top: function() {\r\n                    positions.flip.top.apply( this, arguments );\r\n                    positions.fit.top.apply( this, arguments );\r\n                }\r\n            }\r\n        };\r\n\r\n        geom.posit = posit;\r\n    })();\r\n\r\n    return skylark.attach(\"domx.geom\", geom);\r\n});\ndefine('skylark-domx-geom/main',[\r\n    \"skylark-langx/langx\",\r\n    \"./geom\",\r\n    \"skylark-domx-velm\",\r\n    \"skylark-domx-query\"        \r\n],function(langx,geom,velm,$){\r\n   // from ./geom\r\n    velm.delegate([\r\n        \"borderExtents\",\r\n        \"boundingPosition\",\r\n        \"boundingRect\",\r\n        \"clientHeight\",\r\n        \"clientSize\",\r\n        \"clientWidth\",\r\n        \"contentRect\",\r\n        \"height\",\r\n        \"marginExtents\",\r\n        \"offsetParent\",\r\n        \"paddingExtents\",\r\n        \"pagePosition\",\r\n        \"pageRect\",\r\n        \"relativePosition\",\r\n        \"relativeRect\",\r\n        \"scrollIntoView\",\r\n        \"scrollLeft\",\r\n        \"scrollTop\",\r\n        \"size\",\r\n        \"width\"\r\n    ], geom);\r\n\r\n    $.fn.offset = $.wraps.wrapper_value(geom.pagePosition, geom, geom.pagePosition);\r\n\r\n    $.fn.scrollTop = $.wraps.wrapper_value(geom.scrollTop, geom);\r\n\r\n    $.fn.scrollLeft = $.wraps.wrapper_value(geom.scrollLeft, geom);\r\n\r\n    $.fn.position =  function(options) {\r\n        if (!this.length) {\r\n            return this;\r\n        }\r\n\r\n        if (options) {\r\n            if (options.of && options.of.length) {\r\n                options = langx.clone(options);\r\n                options.of = options.of[0];\r\n            }\r\n            return this.each( function() {\r\n                geom.posit(this,options);\r\n            });\r\n        } else {\r\n            var elem = this[0];\r\n\r\n            return geom.relativePosition(elem);\r\n\r\n        }             \r\n    };\r\n\r\n    $.fn.offsetParent = $.wraps.wrapper_map(geom.offsetParent, geom);\r\n\r\n\r\n    $.fn.size = $.wraps.wrapper_value(geom.size, geom);\r\n\r\n    $.fn.width = $.wraps.wrapper_value(geom.width, geom, geom.width);\r\n\r\n    $.fn.height = $.wraps.wrapper_value(geom.height, geom, geom.height);\r\n\r\n    $.fn.clientSize = $.wraps.wrapper_value(geom.clientSize, geom.clientSize);\r\n    \r\n    ['width', 'height'].forEach(function(dimension) {\r\n        var offset, Dimension = dimension.replace(/./, function(m) {\r\n            return m[0].toUpperCase()\r\n        });\r\n\r\n        $.fn['outer' + Dimension] = function(margin, value) {\r\n            if (arguments.length) {\r\n                if (typeof margin !== 'boolean') {\r\n                    value = margin;\r\n                    margin = false;\r\n                }\r\n            } else {\r\n                margin = false;\r\n                value = undefined;\r\n            }\r\n\r\n            if (value === undefined) {\r\n                var el = this[0];\r\n                if (!el) {\r\n                    return undefined;\r\n                }\r\n                var cb = geom.size(el);\r\n                if (margin) {\r\n                    var me = geom.marginExtents(el);\r\n                    cb.width = cb.width + me.left + me.right;\r\n                    cb.height = cb.height + me.top + me.bottom;\r\n                }\r\n                return dimension === \"width\" ? cb.width : cb.height;\r\n            } else {\r\n                return this.each(function(idx, el) {\r\n                    var mb = {};\r\n                    var me = geom.marginExtents(el);\r\n                    if (dimension === \"width\") {\r\n                        mb.width = value;\r\n                        if (margin) {\r\n                            mb.width = mb.width - me.left - me.right\r\n                        }\r\n                    } else {\r\n                        mb.height = value;\r\n                        if (margin) {\r\n                            mb.height = mb.height - me.top - me.bottom;\r\n                        }\r\n                    }\r\n                    geom.size(el, mb);\r\n                })\r\n\r\n            }\r\n        };\r\n    })\r\n\r\n    $.fn.innerWidth = $.wraps.wrapper_value(geom.clientWidth, geom, geom.clientWidth);\r\n\r\n    $.fn.innerHeight = $.wraps.wrapper_value(geom.clientHeight, geom, geom.clientHeight);\r\n\r\n    return geom;\r\n});\ndefine('skylark-domx-geom', ['skylark-domx-geom/main'], function (main) { return main; });\n\n"]}