{"version":3,"sources":["geom.js"],"names":["define","skylark","langx","noder","styler","cachedScrollbarWidth","rootNodeRE","px","toPixel","offsetParent","scrollbarWidth","undefined","w1","w2","div","createFragment","innerDiv","childNodes","append","document","body","offsetWidth","css","clientWidth","remove","borderExtents","elm","isWindow","left","top","right","bottom","s","getComputedStyle","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","boundingPosition","coords","test","nodeName","getBoundingClientRect","parent","parentOffset","mex","marginExtents","pbex","relativePosition","this","boundingRect","size","clientSize","dimension","width","height","clientHeight","isBorderBox","props","bex","pex","paddingExtents","getDocumentSize","doc","documentElement","max","Math","scrollWidth","scrollHeight","offsetHeight","marginLeft","marginTop","marginRight","marginBottom","marginSize","obj","me","paddingLeft","paddingTop","paddingRight","paddingBottom","pagePosition","window","pageXOffset","pageYOffset","offset","relativeRect","scrollLeft","value","nodeType","defaultView","hasScrollLeft","scrollTo","scrollY","scrollTop","hasScrollTop","scrollX","innerWidth","innerHeight","isDocument","geom","mixin","contentRect","cs","fullCover","elem","hor","vert","vertical","horizontal","isUndefined","style","position","isVisible","offsetTop","offsetLeft","marginRect","pageRect","round","scrollIntoView","align","x","y","parentWidth","parentHeight","parentElm","parentNode","pos","rootElm","getOffset","testAxis","result","abs","rhorizontal","rvertical","roffset","rposition","rpercent","getOffsets","offsets","parseFloat","parseCss","element","property","parseInt","positions","fit","data","newOverRight","within","withinOffset","outerWidth","collisionPosLeft","collisionPosition","overLeft","overRight","collisionWidth","newOverBottom","outerHeight","collisionPosTop","overTop","overBottom","collisionHeight","flip","newOverLeft","myOffset","my","elemWidth","atOffset","at","targetWidth","newOverTop","elemHeight","targetHeight","flipfit","apply","arguments","posit","options","targetOffset","basePosition","dimensions","withinElement","hasOffset","msize","raw","target","extend","of","scrollInfo","overflowX","overflowY","hasOverflowX","getScrollInfo","collision","split","preventDefault","pageY","pageX","each","horizontalOffset","verticalOffset","length","concat","exec","using","i","dir","feedback","important","call","attach"],"mappings":"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","file":"../geom.js","sourcesContent":["define([\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\"\r\n], function(skylark, langx, noder, styler) {\r\n    var rootNodeRE = /^(?:body|html)$/i,\r\n        px = langx.toPixel,\r\n        offsetParent = noder.offsetParent,\r\n        cachedScrollbarWidth;\r\n\r\n    function scrollbarWidth() {\r\n        if (cachedScrollbarWidth !== undefined) {\r\n            return cachedScrollbarWidth;\r\n        }\r\n        var w1, w2,\r\n            div = noder.createFragment(\"<div style=\" +\r\n                \"'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>\" +\r\n                \"<div style='height:300px;width:auto;'></div></div>\")[0],\r\n            innerDiv = div.childNodes[0];\r\n\r\n        noder.append(document.body, div);\r\n\r\n        w1 = innerDiv.offsetWidth;\r\n\r\n        styler.css(div, \"overflow\", \"scroll\");\r\n\r\n        w2 = innerDiv.offsetWidth;\r\n\r\n        if (w1 === w2) {\r\n            w2 = div[0].clientWidth;\r\n        }\r\n\r\n        noder.remove(div);\r\n\r\n        return (cachedScrollbarWidth = w1 - w2);\r\n    }\r\n    /*\r\n     * Get the widths of each border of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function borderExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.borderLeftWidth, elm),\r\n            top: px(s.borderTopWidth, elm),\r\n            right: px(s.borderRightWidth, elm),\r\n            bottom: px(s.borderBottomWidth, elm)\r\n        }\r\n    }\r\n\r\n\r\n    //viewport coordinate\r\n    /*\r\n     * Get or set the viewport position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingPosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            return rootNodeRE.test(elm.nodeName) ? { top: 0, left: 0 } : elm.getBoundingClientRect();\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Get or set the viewport rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function boundingRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            return elm.getBoundingClientRect()\r\n        } else {\r\n            boundingPosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the height of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function clientHeight(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).height;\r\n        } else {\r\n            return clientSize(elm, {\r\n                height: value\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the size of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientSize(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            return {\r\n                width: elm.clientWidth,\r\n                height: elm.clientHeight\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width - pex.left - pex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height - pex.top - pex.bottom;\r\n                }\r\n            } else {\r\n                var bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined) {\r\n                    props.width = props.width + bex.left + bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined) {\r\n                    props.height = props.height + bex.top + bex.bottom;\r\n                }\r\n\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n        return {\r\n            width: elm.clientWidth,\r\n            height: elm.clientHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get or set the width of the specified element client box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} dimension\r\n     */\r\n    function clientWidth(elm, value) {\r\n        if (value == undefined) {\r\n            return clientSize(elm).width;\r\n        } else {\r\n            clientSize(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the rect of the specified element content box.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function contentRect(elm) {\r\n        var cs = clientSize(elm),\r\n            pex = paddingExtents(elm);\r\n\r\n\r\n        //// On Opera, offsetLeft includes the parent's border\r\n        //if(has(\"opera\")){\r\n        //    pe.l += be.l;\r\n        //    pe.t += be.t;\r\n        //}\r\n        return {\r\n            left: pex.left,\r\n            top: pex.top,\r\n            width: cs.width - pex.left - pex.right,\r\n            height: cs.height - pex.top - pex.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function fullCover(elem, hor, vert) {\r\n        let vertical = vert;\r\n        let horizontal = hor;\r\n        if (langx.isUndefined(horizontal)) {\r\n            horizontal = true;\r\n        }\r\n        if (langx.isUndefined(vertical)) {\r\n            vertical = true;\r\n        }\r\n        elem.style.position = 'absolute';\r\n        if (horizontal) {\r\n            elem.style.left = 0;\r\n            elem.style.right = 0;\r\n        }\r\n        if (vertical) {\r\n            elem.style.top = 0;\r\n            elem.style.bottom = 0;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLDocument} doc\r\n     */\r\n    function getDocumentSize(doc) {\r\n        var documentElement = doc.documentElement,\r\n            body = doc.body,\r\n            max = Math.max,\r\n            scrollWidth = max(documentElement.scrollWidth, body.scrollWidth),\r\n            clientWidth = max(documentElement.clientWidth, body.clientWidth),\r\n            offsetWidth = max(documentElement.offsetWidth, body.offsetWidth),\r\n            scrollHeight = max(documentElement.scrollHeight, body.scrollHeight),\r\n            clientHeight = max(documentElement.clientHeight, body.clientHeight),\r\n            offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n\r\n        return {\r\n            width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n            height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the document size.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function height(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).height;\r\n        } else {\r\n            size(elm, {\r\n                height: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a DOM element in completely visible in the viewport\r\n     *\r\n     * @method isVisible\r\n     * @param {DOM} elm DOM element to test.\r\n     * @return {Boolean} True if the element is inside of the browser viewport.\r\n     */\r\n    function isVisible(elm)   {\r\n        var top = elm.offsetTop;\r\n        var left = elm.offsetLeft;\r\n        var width = elm.offsetWidth;\r\n        var height = elm.offsetHeight;\r\n\r\n        while(elm.offsetParent)  {\r\n            elm = elm.offsetParent;\r\n            top += elm.offsetTop;\r\n            left += elm.offsetLeft;\r\n        }\r\n\r\n        return value = top >= window.pageYOffset && \r\n                       left >= window.pageXOffset && \r\n                       (top + height) <= (window.pageYOffset + window.innerHeight) && \r\n                       (left + width) <= (window.pageXOffset + window.innerWidth);\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each margin of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function marginExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.marginLeft),\r\n            top: px(s.marginTop),\r\n            right: px(s.marginRight),\r\n            bottom: px(s.marginBottom),\r\n        }\r\n    }\r\n\r\n\r\n    function marginRect(elm) {\r\n        var obj = relativeRect(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            left: obj.left,\r\n            top: obj.top,\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n\r\n    function marginSize(elm) {\r\n        var obj = size(elm),\r\n            me = marginExtents(elm);\r\n\r\n        return {\r\n            width: obj.width + me.left + me.right,\r\n            height: obj.height + me.top + me.bottom\r\n        };\r\n    }\r\n\r\n    /*\r\n     * Get the widths of each padding of the specified element.\r\n     * @param {HTMLElement} elm\r\n     */\r\n    function paddingExtents(elm) {\r\n        if (noder.isWindow(elm)) {\r\n            return {\r\n                left : 0,\r\n                top : 0,\r\n                right : 0,\r\n                bottom : 0\r\n            }\r\n        }\r\n        var s = getComputedStyle(elm);\r\n        return {\r\n            left: px(s.paddingLeft),\r\n            top: px(s.paddingTop),\r\n            right: px(s.paddingRight),\r\n            bottom: px(s.paddingBottom),\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document position of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    //coordinate to the document\r\n    function pagePosition(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset\r\n            }\r\n        } else {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                parentOffset = pagePosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            relativePosition(elm, {\r\n                top: coords.top - parentOffset.top - mex.top - pbex.top,\r\n                left: coords.left - parentOffset.left - mex.left - pbex.left\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the document rect of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function pageRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var obj = elm.getBoundingClientRect()\r\n            return {\r\n                left: obj.left + window.pageXOffset,\r\n                top: obj.top + window.pageYOffset,\r\n                width: Math.round(obj.width),\r\n                height: Math.round(obj.height)\r\n            }\r\n        } else {\r\n            pagePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the position of the specified element border box , relative to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    // coordinate relative to it's parent\r\n    function relativePosition(elm, coords) {\r\n        if (coords == undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingPosition(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left\r\n            }\r\n        } else {\r\n            var props = {\r\n                top: coords.top,\r\n                left: coords.left\r\n            }\r\n\r\n            if (styler.css(elm, \"position\") == \"static\") {\r\n                props['position'] = \"relative\";\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Get or set the rect of the specified element border box , relatived to parent element.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} coords\r\n     */\r\n    function relativeRect(elm, coords) {\r\n        if (coords === undefined) {\r\n            var // Get *real* offsetParent\r\n                parent = offsetParent(elm),\r\n                // Get correct offsets\r\n                offset = boundingRect(elm),\r\n                parentOffset = boundingPosition(parent),\r\n                mex = marginExtents(elm),\r\n                pbex = borderExtents(parent);\r\n\r\n            // Subtract parent offsets and element margins\r\n            return {\r\n                top: offset.top - parentOffset.top - pbex.top, // - mex.top,\r\n                left: offset.left - parentOffset.left - pbex.left, // - mex.left,\r\n                width: offset.width,\r\n                height: offset.height\r\n            }\r\n        } else {\r\n            relativePosition(elm, coords);\r\n            size(elm, coords);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Scroll the specified element into view.\r\n     * @param {HTMLElement} elm\r\n     * @param {} align\r\n     */\r\n    function scrollIntoView(elm, align) {\r\n        function getOffset(elm, rootElm) {\r\n            var x, y, parent = elm;\r\n\r\n            x = y = 0;\r\n            while (parent && parent != rootElm && parent.nodeType) {\r\n                x += parent.offsetLeft || 0;\r\n                y += parent.offsetTop || 0;\r\n                parent = parent.offsetParent;\r\n            }\r\n\r\n            return { x: x, y: y };\r\n        }\r\n\r\n        var parentElm = elm.parentNode;\r\n        var x, y, width, height, parentWidth, parentHeight;\r\n        var pos = getOffset(elm, parentElm);\r\n\r\n        x = pos.x;\r\n        y = pos.y;\r\n        width = elm.offsetWidth;\r\n        height = elm.offsetHeight;\r\n        parentWidth = parentElm.clientWidth;\r\n        parentHeight = parentElm.clientHeight;\r\n\r\n        if (align == \"end\") {\r\n            x -= parentWidth - width;\r\n            y -= parentHeight - height;\r\n        } else if (align == \"center\") {\r\n            x -= (parentWidth / 2) - (width / 2);\r\n            y -= (parentHeight / 2) - (height / 2);\r\n        }\r\n\r\n        parentElm.scrollLeft = x;\r\n        parentElm.scrollTop = y;\r\n\r\n        return this;\r\n    }\r\n    /*\r\n     * Get or set the current horizontal position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollLeft(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        }\r\n        var hasScrollLeft = \"scrollLeft\" in elm;\r\n        if (value === undefined) {\r\n            return hasScrollLeft ? elm.scrollLeft : elm.pageXOffset\r\n        } else {\r\n            if (hasScrollLeft) {\r\n                elm.scrollLeft = value;\r\n            } else {\r\n                elm.scrollTo(value, elm.scrollY);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or the current vertical position of the scroll bar for the specified element.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function scrollTop(elm, value) {\r\n        if (elm.nodeType === 9) {\r\n            elm = elm.defaultView;\r\n        }\r\n        var hasScrollTop = \"scrollTop\" in elm;\r\n\r\n        if (value === undefined) {\r\n            return hasScrollTop ? elm.scrollTop : elm.pageYOffset\r\n        } else {\r\n            if (hasScrollTop) {\r\n                elm.scrollTop = value;\r\n            } else {\r\n                elm.scrollTo(elm.scrollX, value);\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject}dimension\r\n     */\r\n    function size(elm, dimension) {\r\n        if (dimension == undefined) {\r\n            if (langx.isWindow(elm)) {\r\n                return {\r\n                    width: elm.innerWidth,\r\n                    height: elm.innerHeight\r\n                }\r\n\r\n            } else if (langx.isDocument(elm)) {\r\n                return getDocumentSize(document);\r\n            } else {\r\n                return {\r\n                    width: elm.offsetWidth,\r\n                    height: elm.offsetHeight\r\n                }\r\n            }\r\n        } else {\r\n            var isBorderBox = (styler.css(elm, \"box-sizing\") === \"border-box\"),\r\n                props = {\r\n                    width: dimension.width,\r\n                    height: dimension.height\r\n                };\r\n            if (!isBorderBox) {\r\n                var pex = paddingExtents(elm),\r\n                    bex = borderExtents(elm);\r\n\r\n                if (props.width !== undefined && props.width !== \"\" && props.width !== null) {\r\n                    props.width = props.width - pex.left - pex.right - bex.left - bex.right;\r\n                }\r\n\r\n                if (props.height !== undefined && props.height !== \"\" && props.height !== null) {\r\n                    props.height = props.height - pex.top - pex.bottom - bex.top - bex.bottom;\r\n                }\r\n            }\r\n            styler.css(elm, props);\r\n            return this;\r\n        }\r\n    }\r\n    /*\r\n     * Get or set the size of the specified element border box.\r\n     * @param {HTMLElement} elm\r\n     * @param {Number} value\r\n     */\r\n    function width(elm, value) {\r\n        if (value == undefined) {\r\n            return size(elm).width;\r\n        } else {\r\n            size(elm, {\r\n                width: value\r\n            });\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a DOM element is out of the window and how far it is, returns object with x and y values.\r\n     * \r\n     * If the value is 0 the element is inside the window on that axis.\r\n     *\r\n     * @method testAxis\r\n     * @param {DOM} elm DOM element to test.\r\n     * @return {Vector2} Distance outside of the viewport.\r\n     */\r\n    function testAxis(elm) {\r\n        var top = elm.offsetTop;\r\n        var left = elm.offsetLeft;\r\n        var width = elm.offsetWidth;\r\n        var height = elm.offsetHeight;\r\n\r\n        while(elm.offsetParent) {\r\n            elm = elm.offsetParent;\r\n            top += elm.offsetTop;\r\n            left += elm.offsetLeft;\r\n        }\r\n\r\n        var result = {x: 0, y: 0};\r\n\r\n        //Over the top of the window\r\n        if(top < window.pageYOffset) {\r\n            result.y = top - window.pageYOffset;\r\n        }\r\n        //Bellow the window\r\n        else if((top + height) > (window.pageYOffset + window.innerHeight))\r\n        {\r\n            result.y = (top + height) - (window.pageYOffset + window.innerHeight);\r\n        }\r\n\r\n        //Left to the window\r\n        if(left < window.pageXOffset) {\r\n            result.x = left - window.pageXOffset;\r\n        }\r\n        //Right to the window\r\n        else if((left + width) > (window.pageXOffset + window.innerWidth))\r\n        {\r\n            result.x = (left + width) - (window.pageXOffset + window.innerWidth);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    function geom() {\r\n        return geom;\r\n    }\r\n\r\n    langx.mixin(geom, {\r\n        borderExtents: borderExtents,\r\n        //viewport coordinate\r\n        boundingPosition: boundingPosition,\r\n\r\n        boundingRect: boundingRect,\r\n\r\n        clientHeight: clientHeight,\r\n\r\n        clientSize: clientSize,\r\n\r\n        clientWidth: clientWidth,\r\n\r\n        contentRect: contentRect,\r\n\r\n        fullCover,\r\n\r\n        getDocumentSize: getDocumentSize,\r\n\r\n        height: height,\r\n\r\n        isVisible,\r\n\r\n        marginExtents: marginExtents,\r\n\r\n        marginRect: marginRect,\r\n\r\n        marginSize: marginSize,\r\n\r\n        offsetParent: offsetParent,\r\n\r\n        paddingExtents: paddingExtents,\r\n\r\n        //coordinate to the document\r\n        pagePosition: pagePosition,\r\n\r\n        pageRect: pageRect,\r\n\r\n        // coordinate relative to it's parent\r\n        relativePosition: relativePosition,\r\n\r\n        relativeRect: relativeRect,\r\n\r\n        scrollbarWidth: scrollbarWidth,\r\n\r\n        scrollIntoView: scrollIntoView,\r\n\r\n        scrollLeft: scrollLeft,\r\n\r\n        scrollTop: scrollTop,\r\n\r\n        size: size,\r\n\r\n        testAxis,\r\n\r\n        width: width\r\n    });\r\n\r\n\r\n    /*\r\n     * Position an element relative to the window, document, another element, or the cursor/mouse.\r\n     * see https://jqueryui.com/position/\r\n     */\r\n    ( function() {\r\n        var max = Math.max,\r\n            abs = Math.abs,\r\n            rhorizontal = /left|center|right/,\r\n            rvertical = /top|center|bottom/,\r\n            roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\r\n            rposition = /^\\w+/,\r\n            rpercent = /%$/;\r\n\r\n        function getOffsets( offsets, width, height ) {\r\n            return [\r\n                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\r\n                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\r\n            ];\r\n        }\r\n\r\n        function parseCss( element, property ) {\r\n            return parseInt( styler.css( element, property ), 10 ) || 0;\r\n        }\r\n\r\n        function getDimensions( raw ) {\r\n            if ( raw.nodeType === 9 ) {\r\n                return {\r\n                    size: size(raw),\r\n                    offset: { top: 0, left: 0 }\r\n                };\r\n            }\r\n            if ( noder.isWindow( raw ) ) {\r\n                return {\r\n                    size: size(raw),\r\n                    offset: { \r\n                        top: scrollTop(raw), \r\n                        left: scrollLeft(raw) \r\n                    }\r\n                };\r\n            }\r\n            if ( raw.preventDefault ) {\r\n                return {\r\n                    size : {\r\n                        width: 0,\r\n                        height: 0\r\n                    },\r\n                    offset: { \r\n                        top: raw.pageY, \r\n                        left: raw.pageX \r\n                    }\r\n                };\r\n            }\r\n            return {\r\n                size: size(raw),\r\n                offset: pagePosition(raw)\r\n            };\r\n        }\r\n\r\n        function getScrollInfo( within ) {\r\n            var overflowX = within.isWindow || within.isDocument ? \"\" :\r\n                    styler.css(within.element,\"overflow-x\" ),\r\n                overflowY = within.isWindow || within.isDocument ? \"\" :\r\n                    styler.css(within.element,\"overflow-y\" ),\r\n                hasOverflowX = overflowX === \"scroll\" ||\r\n                    ( overflowX === \"auto\" && within.width < scrollWidth(within.element) ),\r\n                hasOverflowY = overflowY === \"scroll\" ||\r\n                    ( overflowY === \"auto\" && within.height < scrollHeight(within.element));\r\n            return {\r\n                width: hasOverflowY ? scrollbarWidth() : 0,\r\n                height: hasOverflowX ? scrollbarWidth() : 0\r\n            };\r\n        }\r\n\r\n        function getWithinInfo( element ) {\r\n            var withinElement = element || window,\r\n                isWindow = noder.isWindow( withinElement),\r\n                isDocument = !!withinElement && withinElement.nodeType === 9,\r\n                hasOffset = !isWindow && !isDocument,\r\n                msize = marginSize(withinElement);\r\n            return {\r\n                element: withinElement,\r\n                isWindow: isWindow,\r\n                isDocument: isDocument,\r\n                offset: hasOffset ? pagePosition(element) : { left: 0, top: 0 },\r\n                scrollLeft: scrollLeft(withinElement),\r\n                scrollTop: scrollTop(withinElement),\r\n                width: msize.width,\r\n                height: msize.height\r\n            };\r\n        }\r\n\r\n        function posit(elm,options ) {\r\n            // Make a copy, we don't want to modify arguments\r\n            options = langx.extend( {}, options );\r\n\r\n            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\r\n                target = options.of,\r\n                within = getWithinInfo( options.within ),\r\n                scrollInfo = getScrollInfo( within ),\r\n                collision = ( options.collision || \"flip\" ).split( \" \" ),\r\n                offsets = {};\r\n\r\n            dimensions = getDimensions( target );\r\n            if ( target.preventDefault ) {\r\n\r\n                // Force left top to allow flipping\r\n                options.at = \"left top\";\r\n            }\r\n            targetWidth = dimensions.size.width;\r\n            targetHeight = dimensions.size.height;\r\n            targetOffset = dimensions.offset;\r\n\r\n            // Clone to reuse original targetOffset later\r\n            basePosition = langx.extend( {}, targetOffset );\r\n\r\n            // Force my and at to have valid horizontal and vertical positions\r\n            // if a value is missing or invalid, it will be converted to center\r\n            langx.each( [ \"my\", \"at\" ], function() {\r\n                var pos = ( options[ this ] || \"\" ).split( \" \" ),\r\n                    horizontalOffset,\r\n                    verticalOffset;\r\n\r\n                if ( pos.length === 1 ) {\r\n                    pos = rhorizontal.test( pos[ 0 ] ) ?\r\n                        pos.concat( [ \"center\" ] ) :\r\n                        rvertical.test( pos[ 0 ] ) ?\r\n                            [ \"center\" ].concat( pos ) :\r\n                            [ \"center\", \"center\" ];\r\n                }\r\n                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\r\n                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\r\n\r\n                // Calculate offsets\r\n                horizontalOffset = roffset.exec( pos[ 0 ] );\r\n                verticalOffset = roffset.exec( pos[ 1 ] );\r\n                offsets[ this ] = [\r\n                    horizontalOffset ? horizontalOffset[ 0 ] : 0,\r\n                    verticalOffset ? verticalOffset[ 0 ] : 0\r\n                ];\r\n\r\n                // Reduce to just the positions without the offsets\r\n                options[ this ] = [\r\n                    rposition.exec( pos[ 0 ] )[ 0 ],\r\n                    rposition.exec( pos[ 1 ] )[ 0 ]\r\n                ];\r\n            } );\r\n\r\n            // Normalize collision option\r\n            if ( collision.length === 1 ) {\r\n                collision[ 1 ] = collision[ 0 ];\r\n            }\r\n\r\n            if ( options.at[ 0 ] === \"right\" ) {\r\n                basePosition.left += targetWidth;\r\n            } else if ( options.at[ 0 ] === \"center\" ) {\r\n                basePosition.left += targetWidth / 2;\r\n            }\r\n\r\n            if ( options.at[ 1 ] === \"bottom\" ) {\r\n                basePosition.top += targetHeight;\r\n            } else if ( options.at[ 1 ] === \"center\" ) {\r\n                basePosition.top += targetHeight / 2;\r\n            }\r\n\r\n            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\r\n            basePosition.left += atOffset[ 0 ];\r\n            basePosition.top += atOffset[ 1 ];\r\n\r\n            return ( function(elem) {\r\n                var collisionPosition, using,\r\n                    msize = marginSize(elem),\r\n                    elemWidth = msize.width,\r\n                    elemHeight = msize.height,\r\n                    marginLeft = parseCss( elem, \"marginLeft\" ),\r\n                    marginTop = parseCss( elem, \"marginTop\" ),\r\n                    collisionWidth = elemWidth + marginLeft + parseCss( elem, \"marginRight\" ) +\r\n                        scrollInfo.width,\r\n                    collisionHeight = elemHeight + marginTop + parseCss( elem, \"marginBottom\" ) +\r\n                        scrollInfo.height,\r\n                    position = langx.extend( {}, basePosition ),\r\n                    myOffset = getOffsets( offsets.my, msize.width, msize.height);\r\n\r\n                if ( options.my[ 0 ] === \"right\" ) {\r\n                    position.left -= elemWidth;\r\n                } else if ( options.my[ 0 ] === \"center\" ) {\r\n                    position.left -= elemWidth / 2;\r\n                }\r\n\r\n                if ( options.my[ 1 ] === \"bottom\" ) {\r\n                    position.top -= elemHeight;\r\n                } else if ( options.my[ 1 ] === \"center\" ) {\r\n                    position.top -= elemHeight / 2;\r\n                }\r\n\r\n                position.left += myOffset[ 0 ];\r\n                position.top += myOffset[ 1 ];\r\n\r\n                collisionPosition = {\r\n                    marginLeft: marginLeft,\r\n                    marginTop: marginTop\r\n                };\r\n\r\n                langx.each( [ \"left\", \"top\" ], function( i, dir ) {\r\n                    if ( positions[ collision[ i ] ] ) {\r\n                        positions[ collision[ i ] ][ dir ]( position, {\r\n                            targetWidth: targetWidth,\r\n                            targetHeight: targetHeight,\r\n                            elemWidth: elemWidth,\r\n                            elemHeight: elemHeight,\r\n                            collisionPosition: collisionPosition,\r\n                            collisionWidth: collisionWidth,\r\n                            collisionHeight: collisionHeight,\r\n                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\r\n                            my: options.my,\r\n                            at: options.at,\r\n                            within: within,\r\n                            elem: elem\r\n                        } );\r\n                    }\r\n                } );\r\n\r\n                if ( options.using ) {\r\n\r\n                    // Adds feedback as second argument to using callback, if present\r\n                    using = function( props ) {\r\n                        var left = targetOffset.left - position.left,\r\n                            right = left + targetWidth - elemWidth,\r\n                            top = targetOffset.top - position.top,\r\n                            bottom = top + targetHeight - elemHeight,\r\n                            feedback = {\r\n                                target: {\r\n                                    element: target,\r\n                                    left: targetOffset.left,\r\n                                    top: targetOffset.top,\r\n                                    width: targetWidth,\r\n                                    height: targetHeight\r\n                                },\r\n                                element: {\r\n                                    element: elem,\r\n                                    left: position.left,\r\n                                    top: position.top,\r\n                                    width: elemWidth,\r\n                                    height: elemHeight\r\n                                },\r\n                                horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\r\n                                vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\r\n                            };\r\n                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\r\n                            feedback.horizontal = \"center\";\r\n                        }\r\n                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\r\n                            feedback.vertical = \"middle\";\r\n                        }\r\n                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\r\n                            feedback.important = \"horizontal\";\r\n                        } else {\r\n                            feedback.important = \"vertical\";\r\n                        }\r\n                        options.using.call( this, props, feedback );\r\n                    };\r\n                }\r\n\r\n                pagePosition(elem, langx.extend( position, { using: using } ));\r\n            })(elm);\r\n        }\r\n\r\n        var positions = {\r\n            fit: {\r\n                left: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                        outerWidth = within.width,\r\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                        overLeft = withinOffset - collisionPosLeft,\r\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\r\n                        newOverRight;\r\n\r\n                    // Element is wider than within\r\n                    if ( data.collisionWidth > outerWidth ) {\r\n\r\n                        // Element is initially over the left side of within\r\n                        if ( overLeft > 0 && overRight <= 0 ) {\r\n                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\r\n                                withinOffset;\r\n                            position.left += overLeft - newOverRight;\r\n\r\n                        // Element is initially over right side of within\r\n                        } else if ( overRight > 0 && overLeft <= 0 ) {\r\n                            position.left = withinOffset;\r\n\r\n                        // Element is initially over both left and right sides of within\r\n                        } else {\r\n                            if ( overLeft > overRight ) {\r\n                                position.left = withinOffset + outerWidth - data.collisionWidth;\r\n                            } else {\r\n                                position.left = withinOffset;\r\n                            }\r\n                        }\r\n\r\n                    // Too far left -> align with left edge\r\n                    } else if ( overLeft > 0 ) {\r\n                        position.left += overLeft;\r\n\r\n                    // Too far right -> align with right edge\r\n                    } else if ( overRight > 0 ) {\r\n                        position.left -= overRight;\r\n\r\n                    // Adjust based on position and margin\r\n                    } else {\r\n                        position.left = max( position.left - collisionPosLeft, position.left );\r\n                    }\r\n                },\r\n                top: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\r\n                        outerHeight = data.within.height,\r\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                        overTop = withinOffset - collisionPosTop,\r\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\r\n                        newOverBottom;\r\n\r\n                    // Element is taller than within\r\n                    if ( data.collisionHeight > outerHeight ) {\r\n\r\n                        // Element is initially over the top of within\r\n                        if ( overTop > 0 && overBottom <= 0 ) {\r\n                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\r\n                                withinOffset;\r\n                            position.top += overTop - newOverBottom;\r\n\r\n                        // Element is initially over bottom of within\r\n                        } else if ( overBottom > 0 && overTop <= 0 ) {\r\n                            position.top = withinOffset;\r\n\r\n                        // Element is initially over both top and bottom of within\r\n                        } else {\r\n                            if ( overTop > overBottom ) {\r\n                                position.top = withinOffset + outerHeight - data.collisionHeight;\r\n                            } else {\r\n                                position.top = withinOffset;\r\n                            }\r\n                        }\r\n\r\n                    // Too far up -> align with top\r\n                    } else if ( overTop > 0 ) {\r\n                        position.top += overTop;\r\n\r\n                    // Too far down -> align with bottom edge\r\n                    } else if ( overBottom > 0 ) {\r\n                        position.top -= overBottom;\r\n\r\n                    // Adjust based on position and margin\r\n                    } else {\r\n                        position.top = max( position.top - collisionPosTop, position.top );\r\n                    }\r\n                }\r\n            },\r\n            flip: {\r\n                left: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.offset.left + within.scrollLeft,\r\n                        outerWidth = within.width,\r\n                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                        overLeft = collisionPosLeft - offsetLeft,\r\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\r\n                        myOffset = data.my[ 0 ] === \"left\" ?\r\n                            -data.elemWidth :\r\n                            data.my[ 0 ] === \"right\" ?\r\n                                data.elemWidth :\r\n                                0,\r\n                        atOffset = data.at[ 0 ] === \"left\" ?\r\n                            data.targetWidth :\r\n                            data.at[ 0 ] === \"right\" ?\r\n                                -data.targetWidth :\r\n                                0,\r\n                        offset = -2 * data.offset[ 0 ],\r\n                        newOverRight,\r\n                        newOverLeft;\r\n\r\n                    if ( overLeft < 0 ) {\r\n                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\r\n                            outerWidth - withinOffset;\r\n                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\r\n                            position.left += myOffset + atOffset + offset;\r\n                        }\r\n                    } else if ( overRight > 0 ) {\r\n                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\r\n                            atOffset + offset - offsetLeft;\r\n                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\r\n                            position.left += myOffset + atOffset + offset;\r\n                        }\r\n                    }\r\n                },\r\n                top: function( position, data ) {\r\n                    var within = data.within,\r\n                        withinOffset = within.offset.top + within.scrollTop,\r\n                        outerHeight = within.height,\r\n                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\r\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                        overTop = collisionPosTop - offsetTop,\r\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\r\n                        top = data.my[ 1 ] === \"top\",\r\n                        myOffset = top ?\r\n                            -data.elemHeight :\r\n                            data.my[ 1 ] === \"bottom\" ?\r\n                                data.elemHeight :\r\n                                0,\r\n                        atOffset = data.at[ 1 ] === \"top\" ?\r\n                            data.targetHeight :\r\n                            data.at[ 1 ] === \"bottom\" ?\r\n                                -data.targetHeight :\r\n                                0,\r\n                        offset = -2 * data.offset[ 1 ],\r\n                        newOverTop,\r\n                        newOverBottom;\r\n                    if ( overTop < 0 ) {\r\n                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\r\n                            outerHeight - withinOffset;\r\n                        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\r\n                            position.top += myOffset + atOffset + offset;\r\n                        }\r\n                    } else if ( overBottom > 0 ) {\r\n                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\r\n                            offset - offsetTop;\r\n                        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\r\n                            position.top += myOffset + atOffset + offset;\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            flipfit: {\r\n                left: function() {\r\n                    positions.flip.left.apply( this, arguments );\r\n                    positions.fit.left.apply( this, arguments );\r\n                },\r\n                top: function() {\r\n                    positions.flip.top.apply( this, arguments );\r\n                    positions.fit.top.apply( this, arguments );\r\n                }\r\n            }\r\n        };\r\n\r\n        geom.posit = posit;\r\n    })();\r\n\r\n    return skylark.attach(\"domx.geom\", geom);\r\n});"]}