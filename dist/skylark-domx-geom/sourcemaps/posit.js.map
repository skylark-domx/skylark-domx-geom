{"version":3,"sources":["posit.js"],"names":["define","langx","noder","styler","geom","max","Math","abs","rhorizontal","rvertical","roffset","rposition","rpercent","getOffsets","offsets","width","height","parseFloat","test","parseCss","element","property","parseInt","css","positions","fit","left","position","data","newOverRight","within","withinOffset","isWindow","scrollLeft","offset","outerWidth","collisionPosLeft","collisionPosition","marginLeft","overLeft","overRight","collisionWidth","top","newOverBottom","scrollTop","outerHeight","collisionPosTop","marginTop","overTop","overBottom","collisionHeight","flip","offsetLeft","myOffset","my","elemWidth","atOffset","at","targetWidth","newOverLeft","offsetTop","elemHeight","targetHeight","newOverTop","flipfit","apply","this","arguments","posit","elm","options","targetOffset","hasOffset","elem","using","msize","target","extend","of","withinElement","window","isDocument","nodeType","marginSize","pagePosition","scrollInfo","overflowX","overflowY","hasOverflowX","scrollWidth","scrollHeight","scrollbarWidth","collision","split","dimensions","raw","size","preventDefault","pageY","pageX","basePosition","each","horizontalOffset","verticalOffset","pos","length","concat","exec","i","dir","props","right","bottom","feedback","horizontal","vertical","important","call"],"mappings":"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","file":"../posit.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-styler\",\r\n    \"./geom\"\r\n],function(langx,noder,styler,geom){\r\n  'use strict'\r\n\r\n    var max = Math.max,\r\n        abs = Math.abs,\r\n        rhorizontal = /left|center|right/,\r\n        rvertical = /top|center|bottom/,\r\n        roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\r\n        rposition = /^\\w+/,\r\n        rpercent = /%$/;\r\n\r\n    function getOffsets( offsets, width, height ) {\r\n        return [\r\n            parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\r\n            parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\r\n        ];\r\n    }\r\n\r\n    function parseCss( element, property ) {\r\n        return parseInt( styler.css( element, property ), 10 ) || 0;\r\n    }\r\n\r\n    function getDimensions( raw ) {\r\n        if ( raw.nodeType === 9 ) {\r\n            return {\r\n                size: size(raw),\r\n                offset: { top: 0, left: 0 }\r\n            };\r\n        }\r\n        if ( noder.isWindow( raw ) ) {\r\n            return {\r\n                size: geom.size(raw),\r\n                offset: { \r\n                    top: geom.scrollTop(raw), \r\n                    left: geom.scrollLeft(raw) \r\n                }\r\n            };\r\n        }\r\n        if ( raw.preventDefault ) {\r\n            return {\r\n                size : {\r\n                    width: 0,\r\n                    height: 0\r\n                },\r\n                offset: { \r\n                    top: raw.pageY, \r\n                    left: raw.pageX \r\n                }\r\n            };\r\n        }\r\n        return {\r\n            size: geom.size(raw),\r\n            offset: geom.pagePosition(raw)\r\n        };\r\n    }\r\n\r\n    function getScrollInfo( within ) {\r\n        var overflowX = within.isWindow || within.isDocument ? \"\" :\r\n                styler.css(within.element,\"overflow-x\" ),\r\n            overflowY = within.isWindow || within.isDocument ? \"\" :\r\n                styler.css(within.element,\"overflow-y\" ),\r\n            hasOverflowX = overflowX === \"scroll\" ||\r\n                ( overflowX === \"auto\" && within.width < geom.scrollWidth(within.element) ),\r\n            hasOverflowY = overflowY === \"scroll\" ||\r\n                ( overflowY === \"auto\" && within.height < geom.scrollHeight(within.element));\r\n        return {\r\n            width: hasOverflowY ? geom.scrollbarWidth() : 0,\r\n            height: hasOverflowX ? geom.scrollbarWidth() : 0\r\n        };\r\n    }\r\n\r\n    function getWithinInfo( element ) {\r\n        var withinElement = element || window,\r\n            isWindow = noder.isWindow( withinElement),\r\n            isDocument = !!withinElement && withinElement.nodeType === 9,\r\n            hasOffset = !isWindow && !isDocument,\r\n            msize = geom.marginSize(withinElement);\r\n        return {\r\n            element: withinElement,\r\n            isWindow: isWindow,\r\n            isDocument: isDocument,\r\n            offset: hasOffset ? geom.pagePosition(element) : { left: 0, top: 0 },\r\n            scrollLeft: geom.scrollLeft(withinElement),\r\n            scrollTop: geom.scrollTop(withinElement),\r\n            width: msize.width,\r\n            height: msize.height\r\n        };\r\n    }\r\n\r\n    function posit(elm,options ) {\r\n        // Make a copy, we don't want to modify arguments\r\n        options = langx.extend( {}, options );\r\n\r\n        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\r\n            target = options.of,\r\n            within = getWithinInfo( options.within ),\r\n            scrollInfo = getScrollInfo( within ),\r\n            collision = ( options.collision || \"flip\" ).split( \" \" ),\r\n            offsets = {};\r\n\r\n        dimensions = getDimensions( target );\r\n        if ( target.preventDefault ) {\r\n\r\n            // Force left top to allow flipping\r\n            options.at = \"left top\";\r\n        }\r\n        targetWidth = dimensions.size.width;\r\n        targetHeight = dimensions.size.height;\r\n        targetOffset = dimensions.offset;\r\n\r\n        // Clone to reuse original targetOffset later\r\n        basePosition = langx.extend( {}, targetOffset );\r\n\r\n        // Force my and at to have valid horizontal and vertical positions\r\n        // if a value is missing or invalid, it will be converted to center\r\n        langx.each( [ \"my\", \"at\" ], function() {\r\n            var pos = ( options[ this ] || \"\" ).split( \" \" ),\r\n                horizontalOffset,\r\n                verticalOffset;\r\n\r\n            if ( pos.length === 1 ) {\r\n                pos = rhorizontal.test( pos[ 0 ] ) ?\r\n                    pos.concat( [ \"center\" ] ) :\r\n                    rvertical.test( pos[ 0 ] ) ?\r\n                        [ \"center\" ].concat( pos ) :\r\n                        [ \"center\", \"center\" ];\r\n            }\r\n            pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\r\n            pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\r\n\r\n            // Calculate offsets\r\n            horizontalOffset = roffset.exec( pos[ 0 ] );\r\n            verticalOffset = roffset.exec( pos[ 1 ] );\r\n            offsets[ this ] = [\r\n                horizontalOffset ? horizontalOffset[ 0 ] : 0,\r\n                verticalOffset ? verticalOffset[ 0 ] : 0\r\n            ];\r\n\r\n            // Reduce to just the positions without the offsets\r\n            options[ this ] = [\r\n                rposition.exec( pos[ 0 ] )[ 0 ],\r\n                rposition.exec( pos[ 1 ] )[ 0 ]\r\n            ];\r\n        } );\r\n\r\n        // Normalize collision option\r\n        if ( collision.length === 1 ) {\r\n            collision[ 1 ] = collision[ 0 ];\r\n        }\r\n\r\n        if ( options.at[ 0 ] === \"right\" ) {\r\n            basePosition.left += targetWidth;\r\n        } else if ( options.at[ 0 ] === \"center\" ) {\r\n            basePosition.left += targetWidth / 2;\r\n        }\r\n\r\n        if ( options.at[ 1 ] === \"bottom\" ) {\r\n            basePosition.top += targetHeight;\r\n        } else if ( options.at[ 1 ] === \"center\" ) {\r\n            basePosition.top += targetHeight / 2;\r\n        }\r\n\r\n        atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\r\n        basePosition.left += atOffset[ 0 ];\r\n        basePosition.top += atOffset[ 1 ];\r\n\r\n        return ( function(elem) {\r\n            var collisionPosition, using,\r\n                msize = geom.marginSize(elem),\r\n                elemWidth = msize.width,\r\n                elemHeight = msize.height,\r\n                marginLeft = parseCss( elem, \"marginLeft\" ),\r\n                marginTop = parseCss( elem, \"marginTop\" ),\r\n                collisionWidth = elemWidth + marginLeft + parseCss( elem, \"marginRight\" ) +\r\n                    scrollInfo.width,\r\n                collisionHeight = elemHeight + marginTop + parseCss( elem, \"marginBottom\" ) +\r\n                    scrollInfo.height,\r\n                position = langx.extend( {}, basePosition ),\r\n                myOffset = getOffsets( offsets.my, msize.width, msize.height);\r\n\r\n            if ( options.my[ 0 ] === \"right\" ) {\r\n                position.left -= elemWidth;\r\n            } else if ( options.my[ 0 ] === \"center\" ) {\r\n                position.left -= elemWidth / 2;\r\n            }\r\n\r\n            if ( options.my[ 1 ] === \"bottom\" ) {\r\n                position.top -= elemHeight;\r\n            } else if ( options.my[ 1 ] === \"center\" ) {\r\n                position.top -= elemHeight / 2;\r\n            }\r\n\r\n            position.left += myOffset[ 0 ];\r\n            position.top += myOffset[ 1 ];\r\n\r\n            collisionPosition = {\r\n                marginLeft: marginLeft,\r\n                marginTop: marginTop\r\n            };\r\n\r\n            langx.each( [ \"left\", \"top\" ], function( i, dir ) {\r\n                if ( positions[ collision[ i ] ] ) {\r\n                    positions[ collision[ i ] ][ dir ]( position, {\r\n                        targetWidth: targetWidth,\r\n                        targetHeight: targetHeight,\r\n                        elemWidth: elemWidth,\r\n                        elemHeight: elemHeight,\r\n                        collisionPosition: collisionPosition,\r\n                        collisionWidth: collisionWidth,\r\n                        collisionHeight: collisionHeight,\r\n                        offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\r\n                        my: options.my,\r\n                        at: options.at,\r\n                        within: within,\r\n                        elem: elem\r\n                    } );\r\n                }\r\n            } );\r\n\r\n            if ( options.using ) {\r\n\r\n                // Adds feedback as second argument to using callback, if present\r\n                using = function( props ) {\r\n                    var left = targetOffset.left - position.left,\r\n                        right = left + targetWidth - elemWidth,\r\n                        top = targetOffset.top - position.top,\r\n                        bottom = top + targetHeight - elemHeight,\r\n                        feedback = {\r\n                            target: {\r\n                                element: target,\r\n                                left: targetOffset.left,\r\n                                top: targetOffset.top,\r\n                                width: targetWidth,\r\n                                height: targetHeight\r\n                            },\r\n                            element: {\r\n                                element: elem,\r\n                                left: position.left,\r\n                                top: position.top,\r\n                                width: elemWidth,\r\n                                height: elemHeight\r\n                            },\r\n                            horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\r\n                            vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\r\n                        };\r\n                    if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\r\n                        feedback.horizontal = \"center\";\r\n                    }\r\n                    if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\r\n                        feedback.vertical = \"middle\";\r\n                    }\r\n                    if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\r\n                        feedback.important = \"horizontal\";\r\n                    } else {\r\n                        feedback.important = \"vertical\";\r\n                    }\r\n                    options.using.call( this, props, feedback );\r\n                };\r\n            }\r\n\r\n            geom.pagePosition(elem, langx.extend( position, { using: using } ));\r\n        })(elm);\r\n    }\r\n\r\n    var positions = {\r\n        fit: {\r\n            left: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                    outerWidth = within.width,\r\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                    overLeft = withinOffset - collisionPosLeft,\r\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\r\n                    newOverRight;\r\n\r\n                // Element is wider than within\r\n                if ( data.collisionWidth > outerWidth ) {\r\n\r\n                    // Element is initially over the left side of within\r\n                    if ( overLeft > 0 && overRight <= 0 ) {\r\n                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\r\n                            withinOffset;\r\n                        position.left += overLeft - newOverRight;\r\n\r\n                    // Element is initially over right side of within\r\n                    } else if ( overRight > 0 && overLeft <= 0 ) {\r\n                        position.left = withinOffset;\r\n\r\n                    // Element is initially over both left and right sides of within\r\n                    } else {\r\n                        if ( overLeft > overRight ) {\r\n                            position.left = withinOffset + outerWidth - data.collisionWidth;\r\n                        } else {\r\n                            position.left = withinOffset;\r\n                        }\r\n                    }\r\n\r\n                // Too far left -> align with left edge\r\n                } else if ( overLeft > 0 ) {\r\n                    position.left += overLeft;\r\n\r\n                // Too far right -> align with right edge\r\n                } else if ( overRight > 0 ) {\r\n                    position.left -= overRight;\r\n\r\n                // Adjust based on position and margin\r\n                } else {\r\n                    position.left = max( position.left - collisionPosLeft, position.left );\r\n                }\r\n            },\r\n            top: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\r\n                    outerHeight = data.within.height,\r\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                    overTop = withinOffset - collisionPosTop,\r\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\r\n                    newOverBottom;\r\n\r\n                // Element is taller than within\r\n                if ( data.collisionHeight > outerHeight ) {\r\n\r\n                    // Element is initially over the top of within\r\n                    if ( overTop > 0 && overBottom <= 0 ) {\r\n                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\r\n                            withinOffset;\r\n                        position.top += overTop - newOverBottom;\r\n\r\n                    // Element is initially over bottom of within\r\n                    } else if ( overBottom > 0 && overTop <= 0 ) {\r\n                        position.top = withinOffset;\r\n\r\n                    // Element is initially over both top and bottom of within\r\n                    } else {\r\n                        if ( overTop > overBottom ) {\r\n                            position.top = withinOffset + outerHeight - data.collisionHeight;\r\n                        } else {\r\n                            position.top = withinOffset;\r\n                        }\r\n                    }\r\n\r\n                // Too far up -> align with top\r\n                } else if ( overTop > 0 ) {\r\n                    position.top += overTop;\r\n\r\n                // Too far down -> align with bottom edge\r\n                } else if ( overBottom > 0 ) {\r\n                    position.top -= overBottom;\r\n\r\n                // Adjust based on position and margin\r\n                } else {\r\n                    position.top = max( position.top - collisionPosTop, position.top );\r\n                }\r\n            }\r\n        },\r\n        flip: {\r\n            left: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.offset.left + within.scrollLeft,\r\n                    outerWidth = within.width,\r\n                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\r\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\r\n                    overLeft = collisionPosLeft - offsetLeft,\r\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\r\n                    myOffset = data.my[ 0 ] === \"left\" ?\r\n                        -data.elemWidth :\r\n                        data.my[ 0 ] === \"right\" ?\r\n                            data.elemWidth :\r\n                            0,\r\n                    atOffset = data.at[ 0 ] === \"left\" ?\r\n                        data.targetWidth :\r\n                        data.at[ 0 ] === \"right\" ?\r\n                            -data.targetWidth :\r\n                            0,\r\n                    offset = -2 * data.offset[ 0 ],\r\n                    newOverRight,\r\n                    newOverLeft;\r\n\r\n                if ( overLeft < 0 ) {\r\n                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\r\n                        outerWidth - withinOffset;\r\n                    if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\r\n                        position.left += myOffset + atOffset + offset;\r\n                    }\r\n                } else if ( overRight > 0 ) {\r\n                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\r\n                        atOffset + offset - offsetLeft;\r\n                    if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\r\n                        position.left += myOffset + atOffset + offset;\r\n                    }\r\n                }\r\n            },\r\n            top: function( position, data ) {\r\n                var within = data.within,\r\n                    withinOffset = within.offset.top + within.scrollTop,\r\n                    outerHeight = within.height,\r\n                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\r\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\r\n                    overTop = collisionPosTop - offsetTop,\r\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\r\n                    top = data.my[ 1 ] === \"top\",\r\n                    myOffset = top ?\r\n                        -data.elemHeight :\r\n                        data.my[ 1 ] === \"bottom\" ?\r\n                            data.elemHeight :\r\n                            0,\r\n                    atOffset = data.at[ 1 ] === \"top\" ?\r\n                        data.targetHeight :\r\n                        data.at[ 1 ] === \"bottom\" ?\r\n                            -data.targetHeight :\r\n                            0,\r\n                    offset = -2 * data.offset[ 1 ],\r\n                    newOverTop,\r\n                    newOverBottom;\r\n                if ( overTop < 0 ) {\r\n                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\r\n                        outerHeight - withinOffset;\r\n                    if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\r\n                        position.top += myOffset + atOffset + offset;\r\n                    }\r\n                } else if ( overBottom > 0 ) {\r\n                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\r\n                        offset - offsetTop;\r\n                    if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\r\n                        position.top += myOffset + atOffset + offset;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        flipfit: {\r\n            left: function() {\r\n                positions.flip.left.apply( this, arguments );\r\n                positions.fit.left.apply( this, arguments );\r\n            },\r\n            top: function() {\r\n                positions.flip.top.apply( this, arguments );\r\n                positions.fit.top.apply( this, arguments );\r\n            }\r\n        }\r\n    };\r\n\r\n    return geom.posit = posit;\r\n});"]}